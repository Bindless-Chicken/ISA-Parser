{
    "isa": [
        {
            "key": "sop2",
            "name": "SOP2 Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "S_ADD_U32",
                    "short": "Add two unsigned integers with carry-out",
                    "description": "Add two unsigned integers with carry-out.\n```\nD.u32 = S0.u32 + S1.u32;\nSCC = S0.u32 + S1.u32 >= 0x100000000ULL ? 1 : 0.\n```"
                },
                {
                    "opcode": "1",
                    "name": "S_SUB_U32",
                    "short": "Subtract the second unsigned integer from the first with carry-out",
                    "description": "Subtract the second unsigned integer from the first with carry-out.\n```\nD.u = S0.u - S1.u;\nSCC = (S1.u > S0.u ? 1 : 0). // unsigned overflow or carry-out for S_SUBB_U32.\n```"
                },
                {
                    "opcode": "2",
                    "name": "S_ADD_I32",
                    "short": "Add two signed integers with carry-out",
                    "description": "Add two signed integers with carry-out. This opcode is not suitable for use with S_ADDC_U32 for implementing 64-bit operations.\n```\nD.i = S0.i + S1.i;\nSCC = (S0.u[31] == S1.u[31] && S0.u[31] != D.u[31]). // signed overflow.\n```"
                },
                {
                    "opcode": "3",
                    "name": "S_SUB_I32",
                    "short": "Subtract the second signed integer from the first with carry-out",
                    "description": "Subtract the second signed integer from the first with carry-out. This opcode is not suitable for use with S_SUBB_U32 for implementing 64-bit operations.\n```\nD.i = S0.i - S1.i;\nSCC = (S0.u[31] != S1.u[31] && S0.u[31] != D.u[31]). // signed overflow.\n```"
                },
                {
                    "opcode": "4",
                    "name": "S_ADDC_U32",
                    "short": "Add two unsigned integers with carry-in and carry-out",
                    "description": "Add two unsigned integers with carry-in and carry-out.\n```\nD.u32 = S0.u32 + S1.u32 + SCC;\nSCC = S0.u32 + S1.u32 + SCC >= 0x100000000ULL ? 1 : 0.\n```"
                },
                {
                    "opcode": "5",
                    "name": "S_SUBB_U32",
                    "short": "Subtract the second unsigned integer from the first with carry-in and carry-out",
                    "description": "Subtract the second unsigned integer from the first with carry-in and carry-out.\n```\nD.u = S0.u - S1.u - SCC;\nSCC = (S1.u + SCC > S0.u ? 1 : 0). // unsigned overflow.\n```"
                },
                {
                    "opcode": "6",
                    "name": "S_MIN_I32",
                    "short": "Minimum of two signed integers",
                    "description": "Minimum of two signed integers.\n```\nD.i = (S0.i < S1.i) ? S0.i : S1.i;\nSCC = (S0.i < S1.i).\n```"
                },
                {
                    "opcode": "7",
                    "name": "S_MIN_U32",
                    "short": "Minimum of two unsigned integers",
                    "description": "Minimum of two unsigned integers.\n```\nD.u = (S0.u < S1.u) ? S0.u : S1.u;\nSCC = (S0.u < S1.u).\n```"
                },
                {
                    "opcode": "8",
                    "name": "S_MAX_I32",
                    "short": "Maximum of two signed integers",
                    "description": "Maximum of two signed integers.\n```\nD.i = (S0.i > S1.i) ? S0.i : S1.i;\nSCC = (S0.i > S1.i).\n```"
                },
                {
                    "opcode": "9",
                    "name": "S_MAX_U32",
                    "short": "Maximum of two unsigned integers",
                    "description": "Maximum of two unsigned integers.\n```\nD.u = (S0.u > S1.u) ? S0.u : S1.u;\nSCC = (S0.u > S1.u).\n```"
                },
                {
                    "opcode": "10",
                    "name": "S_CSELECT_B32",
                    "short": "Conditional select based on scalar condition code",
                    "description": "Conditional select based on scalar condition code.\n```\nD.u = SCC ? S0.u : S1.u.\n```"
                },
                {
                    "opcode": "11",
                    "name": "S_CSELECT_B64",
                    "short": "Conditional select base on scalar condition code",
                    "description": "Conditional select base on scalar condition code.\n```\nD.u64 = SCC ? S0.u64 : S1.u64.\n```"
                },
                {
                    "opcode": "14",
                    "name": "S_AND_B32",
                    "short": "Bitwise AND",
                    "description": "Bitwise AND.\n```\nD = S0 & S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "15",
                    "name": "S_AND_B64",
                    "short": "Bitwise AND",
                    "description": "Bitwise AND.\n```\nD = S0 & S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "16",
                    "name": "S_OR_B32",
                    "short": "Bitwise OR",
                    "description": "Bitwise OR.\n```\nD = S0 | S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "17",
                    "name": "S_OR_B64",
                    "short": "Bitwise OR",
                    "description": "Bitwise OR.\n```\nD = S0 | S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "18",
                    "name": "S_XOR_B32",
                    "short": "Bitwise XOR",
                    "description": "Bitwise XOR.\n```\nD = S0 ^ S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "19",
                    "name": "S_XOR_B64",
                    "short": "Bitwise XOR",
                    "description": "Bitwise XOR.\n```\nD = S0 ^ S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "20",
                    "name": "S_ANDN2_B32",
                    "short": "Bitwise ANDN2",
                    "description": "Bitwise ANDN2.\n```\nD = S0 & ~S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "21",
                    "name": "S_ANDN2_B64",
                    "short": "Bitwise ANDN2",
                    "description": "Bitwise ANDN2.\n```\nD = S0 & ~S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "22",
                    "name": "S_ORN2_B32",
                    "short": "Bitwise ORN2",
                    "description": "Bitwise ORN2.\n```\nD = S0 | ~S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "23",
                    "name": "S_ORN2_B64",
                    "short": "Bitwise ORN2",
                    "description": "Bitwise ORN2.\n```\nD = S0 | ~S1;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "24",
                    "name": "S_NAND_B32",
                    "short": "Bitwise NAND",
                    "description": "Bitwise NAND.\n```\nD = ~(S0 & S1);\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "25",
                    "name": "S_NAND_B64",
                    "short": "Bitwise NAND",
                    "description": "Bitwise NAND.\n```\nD = ~(S0 & S1);\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "26",
                    "name": "S_NOR_B32",
                    "short": "Bitwise NOR",
                    "description": "Bitwise NOR.\n```\nD = ~(S0 | S1);\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "27",
                    "name": "S_NOR_B64",
                    "short": "Bitwise NOR",
                    "description": "Bitwise NOR.\n```\nD = ~(S0 | S1);\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "28",
                    "name": "S_XNOR_B32",
                    "short": "Bitwise XNOR",
                    "description": "Bitwise XNOR.\n```\nD = ~(S0 ^ S1);\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "29",
                    "name": "S_XNOR_B64",
                    "short": "Bitwise XNOR",
                    "description": "Bitwise XNOR.\n```\nD = ~(S0 ^ S1);\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "30",
                    "name": "S_LSHL_B32",
                    "short": "Logical shift left",
                    "description": "Logical shift left.\n```\nD.u = S0.u << S1.u[4:0];\nSCC = (D.u != 0).\n```"
                },
                {
                    "opcode": "31",
                    "name": "S_LSHL_B64",
                    "short": "Logical shift left",
                    "description": "Logical shift left.\n```\nD.u64 = S0.u64 << S1.u[5:0];\nSCC = (D.u64 != 0).\n```"
                },
                {
                    "opcode": "32",
                    "name": "S_LSHR_B32",
                    "short": "Logical shift right",
                    "description": "Logical shift right.\n```\nD.u = S0.u >> S1.u[4:0];\nSCC = (D.u != 0).\n```"
                },
                {
                    "opcode": "33",
                    "name": "S_LSHR_B64",
                    "short": "Logical shift right",
                    "description": "Logical shift right.\n```\nD.u64 = S0.u64 >> S1.u[5:0];\nSCC = (D.u64 != 0).\n```"
                },
                {
                    "opcode": "34",
                    "name": "S_ASHR_I32",
                    "short": "Arithmetic shift right (preserve sign bit)",
                    "description": "Arithmetic shift right (preserve sign bit).\n```\nD.i = signext(S0.i) >> S1.u[4:0];\nSCC = (D.i != 0).\n```"
                },
                {
                    "opcode": "35",
                    "name": "S_ASHR_I64",
                    "short": "Arithmetic shift right (preserve sign bit)",
                    "description": "Arithmetic shift right (preserve sign bit).\n```\nD.i64 = signext(S0.i64) >> S1.u[5:0];\nSCC = (D.i64 != 0).\n```"
                },
                {
                    "opcode": "36",
                    "name": "S_BFM_B32",
                    "short": "Bitfield mask",
                    "description": "Bitfield mask.\n```\nD.u = ((1 << S0.u[4:0]) - 1) << S1.u[4:0].\n```"
                },
                {
                    "opcode": "37",
                    "name": "S_BFM_B64",
                    "short": "Bitfield mask",
                    "description": "Bitfield mask.\n```\nD.u64 = ((1ULL << S0.u[5:0]) - 1) << S1.u[5:0].\n```"
                },
                {
                    "opcode": "38",
                    "name": "S_MUL_I32",
                    "short": "Multiply two signed integers",
                    "description": "Multiply two signed integers.\n```\nD.i = S0.i * S1.i.\n```"
                },
                {
                    "opcode": "39",
                    "name": "S_BFE_U32",
                    "short": "Bit field extract",
                    "description": "Bit field extract.  S0 is Data, S1[4:0] is field offset, S1[22:16] is field width.\n```\nD.u = (S0.u >> S1.u[4:0]) & ((1 << S1.u[22:16]) - 1);\nSCC = (D.u != 0).\n```"
                },
                {
                    "opcode": "40",
                    "name": "S_BFE_I32",
                    "short": "Bit field extract",
                    "description": "Bit field extract.  S0 is Data, S1[4:0] is field offset, S1[22:16] is field width.\n```\nD.i = signext((S0.i >> S1.u[4:0]) & ((1 << S1.u[22:16]) - 1));\nSCC = (D.i != 0).\n```"
                },
                {
                    "opcode": "41",
                    "name": "S_BFE_U64",
                    "short": "Bit field extract",
                    "description": "Bit field extract.  S0 is Data, S1[5:0] is field offset, S1[22:16] is field width.\n```\nD.u64 = (S0.u64 >> S1.u[5:0]) & ((1 << S1.u[22:16]) - 1);\nSCC = (D.u64 != 0).\n```"
                },
                {
                    "opcode": "42",
                    "name": "S_BFE_I64",
                    "short": "Bit field extract",
                    "description": "Bit field extract.  S0 is Data, S1[5:0] is field offset, S1[22:16] is field width.\n```\nD.i64 = signext((S0.i64 >> S1.u[5:0]) & ((1 << S1.u[22:16]) - 1));\nSCC = (D.i64 != 0).\n```"
                },
                {
                    "opcode": "44",
                    "name": "S_ABSDIFF_I32",
                    "short": "Compute the absolute value of difference between two values",
                    "description": "Compute the absolute value of difference between two values.\n```\nD.i = S0.i - S1.i;\nif(D.i < 0) then D.i = -D.i;\nendif;\nSCC = (D.i != 0).\n```\nFunctional examples:\n * S_ABSDIFF_I32(0x00000002, 0x00000005) => 0x00000003\n * S_ABSDIFF_I32(0xffffffff, 0x00000000) => 0x00000001\n * S_ABSDIFF_I32(0x80000000, 0x00000000) => 0x80000000// Note: result is negative!\n * S_ABSDIFF_I32(0x80000000, 0x00000001) => 0x7fffffff\n * S_ABSDIFF_I32(0x80000000, 0xffffffff) => 0x7fffffff\n * S_ABSDIFF_I32(0x80000000, 0xfffffffe) => 0x7ffffffe"
                },
                {
                    "opcode": "46",
                    "name": "S_LSHL1_ADD_U32",
                    "short": "Logical shift left by 1 bit and then add",
                    "description": "Logical shift left by 1 bit and then add.\n```\nD.u = (S0.u << N) + S1.u; // N is the shift value in the opcode\nSCC = (((S0.u << N) + S1.u) >= 0x100000000ULL ? 1 : 0). // unsigned overflow.\n```"
                },
                {
                    "opcode": "47",
                    "name": "S_LSHL2_ADD_U32",
                    "short": "Logical shift left by 2 bits and then add",
                    "description": "Logical shift left by 2 bits and then add.\n```\nD.u = (S0.u << N) + S1.u; // N is the shift value in the opcode\nSCC = (((S0.u << N) + S1.u) >= 0x100000000ULL ? 1 : 0). // unsigned overflow.\n```"
                },
                {
                    "opcode": "48",
                    "name": "S_LSHL3_ADD_U32",
                    "short": "Logical shift left by 3 bits and then add",
                    "description": "Logical shift left by 3 bits and then add.\n```\nD.u = (S0.u << N) + S1.u; // N is the shift value in the opcode\nSCC = (((S0.u << N) + S1.u) >= 0x100000000ULL ? 1 : 0). // unsigned overflow.\n```"
                },
                {
                    "opcode": "49",
                    "name": "S_LSHL4_ADD_U32",
                    "short": "Logical shift left by 4 bits and then add",
                    "description": "Logical shift left by 4 bits and then add.\n```\nD.u = (S0.u << N) + S1.u; // N is the shift value in the opcode\nSCC = (((S0.u << N) + S1.u) >= 0x100000000ULL ? 1 : 0). // unsigned overflow.\n```"
                },
                {
                    "opcode": "50",
                    "name": "S_PACK_LL_B32_B16",
                    "short": "Pack two short values into the destination",
                    "description": "Pack two short values into the destination.\n```\nD.u[31:0] = { S1.u[15:0], S0.u[15:0] }.\n```"
                },
                {
                    "opcode": "51",
                    "name": "S_PACK_LH_B32_B16",
                    "short": "Pack two short values into the destination",
                    "description": "Pack two short values into the destination.\n```\nD.u[31:0] = { S1.u[31:16], S0.u[15:0] }.\n```"
                },
                {
                    "opcode": "52",
                    "name": "S_PACK_HH_B32_B16",
                    "short": "Pack two short values into the destination",
                    "description": "Pack two short values into the destination.\n```\nD.u[31:0] = { S1.u[31:16], S0.u[31:16] }.\n```"
                },
                {
                    "opcode": "53",
                    "name": "S_MUL_HI_U32",
                    "short": "Multiple two unsigned integers and store the high 32 bits",
                    "description": "Multiple two unsigned integers and store the high 32 bits.\n```\nD.u = (S0.u * S1.u) >> 32.\n```"
                },
                {
                    "opcode": "54",
                    "name": "S_MUL_HI_I32",
                    "short": "Multiple two signed integers and store the high 32 bits",
                    "description": "Multiple two signed integers and store the high 32 bits.\n```\nD.i = (S0.i * S1.i) >> 32.\n```"
                }
            ]
        },
        {
            "key": "sopk",
            "name": "SOPK Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "S_MOVK_I32",
                    "short": "Sign extension from a 16-bit constant",
                    "description": "Sign extension from a 16-bit constant.\n```\nD.i32 = signext(SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "1",
                    "name": "S_VERSION",
                    "short": "Do nothing",
                    "description": "Do nothing.  Argument is ignored by hardware.  This opcode is not designed for inserting wait states as it is possible the next instruction will issue in the same cycle.  Do not use this opcode to resolve wait state hazards, use S_NOP instead.  \n\nThis opcode is used to specify the microcode version for tools that interpret shader microcode; it may also be used to validate microcode is running with the correct compatibility settings in drivers and functional models that support multiple generations. We strongly encourage this opcode be included at the top of every shader block to simplify debug and catch configuration errors.  \n\nThis opcode must appear in the first 16 bytes of a block of shader code in order to be recognized by external tools and functional models. Avoid placing opcodes > 32 bits or encodings that are not available in all versions of the microcode before the S_VERSION opcode. If this opcode is absent then tools are allowed to make a 'best guess' of the microcode version using cues from the environment; the guess may be incorrect and lead to an invalid decode. It is highly recommended that this be the FIRST opcode of a shader block except for trap handlers, where it should be the SECOND opcode (allowing the first opcode to be a 32-bit branch to accommodate context switch).  \n\nSIMM16[7:0] specifies the microcode version.  \n\nSIMM16[15:8] must be set to zero."
                },
                {
                    "opcode": "2",
                    "name": "S_CMOVK_I32",
                    "short": "Conditional move with sign extension",
                    "description": "Conditional move with sign extension.\n```\nif(SCC)\n\tD.i32 = signext(SIMM16[15:0]);\nendif.\n```"
                },
                {
                    "opcode": "3",
                    "name": "S_CMPK_EQ_I32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.i32 == signext(SIMM16[15:0])).\n```"
                },
                {
                    "opcode": "4",
                    "name": "S_CMPK_LG_I32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.i32 != signext(SIMM16[15:0])).\n```"
                },
                {
                    "opcode": "5",
                    "name": "S_CMPK_GT_I32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.i32 > signext(SIMM16[15:0])).\n```"
                },
                {
                    "opcode": "6",
                    "name": "S_CMPK_GE_I32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.i32 >= signext(SIMM16[15:0])).\n```"
                },
                {
                    "opcode": "7",
                    "name": "S_CMPK_LT_I32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.i32 < signext(SIMM16[15:0])).\n```"
                },
                {
                    "opcode": "8",
                    "name": "S_CMPK_LE_I32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.i32 <= signext(SIMM16[15:0])).\n```"
                },
                {
                    "opcode": "9",
                    "name": "S_CMPK_EQ_U32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.u32 == SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "10",
                    "name": "S_CMPK_LG_U32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.u32 != SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "11",
                    "name": "S_CMPK_GT_U32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.u32 > SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "12",
                    "name": "S_CMPK_GE_U32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.u32 >= SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "13",
                    "name": "S_CMPK_LT_U32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.u32 < SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "14",
                    "name": "S_CMPK_LE_U32",
                    "short": "",
                    "description": "\n```\nSCC = (S0.u32 <= SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "15",
                    "name": "S_ADDK_I32",
                    "short": "Add a 16-bit signed constant to the destination",
                    "description": "Add a 16-bit signed constant to the destination.\n```\nint32 tmp = D.i32; // save value so we can check sign bits for overflow later.\nD.i32 = D.i32 + signext(SIMM16[15:0]);\nSCC = (tmp[31] == SIMM16[15] && tmp[31] != D.i32[31]). // signed overflow.\n```"
                },
                {
                    "opcode": "16",
                    "name": "S_MULK_I32",
                    "short": "Multiply a 16-bit signed constant with the destination",
                    "description": "Multiply a 16-bit signed constant with the destination.\n```\nD.i32 = D.i32 * signext(SIMM16[15:0]).\n```"
                },
                {
                    "opcode": "18",
                    "name": "S_GETREG_B32",
                    "short": "Read some or all of a hardware register into the LSBs of D",
                    "description": "Read some or all of a hardware register into the LSBs of D.\n\nSIMM16 = {size[4:0], offset[4:0], hwRegId[5:0]}; offset is 0..31, size is 1..32.\n```\nuint32 offset = SIMM16[10:6];\nuint32 size = SIMM16[15:11];\nuint32 id = SIMM16[5:0];\nD.u32 = hardware_reg[id][offset+size-1:offset].\n```"
                },
                {
                    "opcode": "19",
                    "name": "S_SETREG_B32",
                    "short": "Write some or all of the LSBs of S0 into a hardware register",
                    "description": "Write some or all of the LSBs of S0 into a hardware register.\n\nSIMM16 = {size[4:0], offset[4:0], hwRegId[5:0]}; offset is 0..31, size is 1..32.\n```\nhardware-reg = S0.u.\n```"
                },
                {
                    "opcode": "21",
                    "name": "S_SETREG_IMM32_B32",
                    "short": "Write some or all of the LSBs of IMM32 into a hardware register",
                    "description": "Write some or all of the LSBs of IMM32 into a hardware register; this instruction requires a 32-bit literal constant.\n\nSIMM16 = {size[4:0], offset[4:0], hwRegId[5:0]}; offset is 0..31, size is 1..32.\n```\nhardware-reg = LITERAL.\n```"
                },
                {
                    "opcode": "22",
                    "name": "S_CALL_B64",
                    "short": "Implements a short call, where the return address (the next instruction after the S_CALL_B64) is saved to D",
                    "description": "Implements a short call, where the return address (the next instruction after the S_CALL_B64) is saved to D. Long calls should consider S_SWAPPC_B64 instead.\n```\nD.u64 = PC + 4;\nPC = PC + signext(SIMM16 * 4) + 4.\n```"
                },
                {
                    "opcode": "23",
                    "name": "S_WAITCNT_VSCNT",
                    "short": "Wait for the counts of outstanding vector store events -- vector memory stores and atomics that DO NOT return data -- to be at or below the specified level",
                    "description": "Wait for the counts of outstanding vector store events -- vector memory stores and atomics that DO NOT return data -- to be at or below the specified level. This counter is not used in 'all-in-order' mode.\n\nWaits for the following condition to hold before continuing:\n```\nvscnt <= S0.u[5:0] + S1.u[5:0]. // Comparison is 6 bits, no clamping is applied for add overflow\n```\nTo wait on a literal constant only, write 'null' for the GPR argument.\n\nSee also S_WAITCNT."
                },
                {
                    "opcode": "24",
                    "name": "S_WAITCNT_VMCNT",
                    "short": "Wait for the counts of outstanding vector memory events -- everything except for memory stores and atomics-without-return -- to be at or below the specified level",
                    "description": "Wait for the counts of outstanding vector memory events -- everything except for memory stores and atomics-without-return -- to be at or below the specified level.  When in 'all-in-order' mode, wait for all vector memory events.\n\nWaits for the following condition to hold before continuing:\n```\nvmcnt <= S0.u[5:0] + S1.u[5:0]. // Comparison is 6 bits, no clamping is applied for add overflow\n```\nTo wait on a literal constant only, write 'null' for the GPR argument or use S_WAITCNT.\n\nSee also S_WAITCNT."
                },
                {
                    "opcode": "25",
                    "name": "S_WAITCNT_EXPCNT",
                    "short": "Waits for the following condition to hold before continuing: expcnt <= S0",
                    "description": "Waits for the following condition to hold before continuing:\n```\nexpcnt <= S0.u[2:0] + S1.u[2:0]. // Comparison is 3 bits, no clamping is applied for add overflow\n```\nTo wait on a literal constant only, write 'null' for the GPR argument or use S_WAITCNT.\n\nSee also S_WAITCNT."
                },
                {
                    "opcode": "26",
                    "name": "S_WAITCNT_LGKMCNT",
                    "short": "Waits for the following condition to hold before continuing: lgkmcnt <= S0",
                    "description": "Waits for the following condition to hold before continuing:\n```\nlgkmcnt <= S0.u[5:0] + S1.u[5:0]. // Comparison is 6 bits, no clamping is applied for add overflow\n```\nTo wait on a literal constant only, write 'null' for the GPR argument or use S_WAITCNT.\n\nSee also S_WAITCNT."
                },
                {
                    "opcode": "27",
                    "name": "S_SUBVECTOR_LOOP_BEGIN",
                    "short": "Begin execution of a subvector block of code",
                    "description": "Begin execution of a subvector block of code. See also S_SUBVECTOR_LOOP_END.\n```\nif(EXEC[63:0] == 0)\n\t// no passes, skip entire loop\n\tjump LABEL\nelif(EXEC_LO == 0)\n\t// execute high pass only\n\tD0 = EXEC_LO\nelse\n\t// execute low pass first, either running both passes or running low pass only\n\tD0 = EXEC_HI\n\tEXEC_HI = 0 \nendif.\n```\nExample:\n```\ns_subvector_loop_begin s0, SKIP_ALL\nLOOP_START:\n\t// instructions\n\t// ...\nLOOP_END:\n\ts_subvector_loop_end s0, LOOP_START\nSKIP_ALL:\n```\nThis opcode is intended to be used in conjunction with S_SUBVECTOR_LOOP_END but there is no dedicated subvector state and internally it is equivalent to an S_CBRANCH with extra math. This opcode has well-defined semantics in wave32 mode but the author of this document is not aware of any practical wave32 programming scenario where it would make sense to use this opcode."
                },
                {
                    "opcode": "28",
                    "name": "S_SUBVECTOR_LOOP_END",
                    "short": "End execution of a subvector block of code",
                    "description": "End execution of a subvector block of code. See also S_SUBVECTOR_LOOP_START.\n```\nif(EXEC_HI != 0)\n\tEXEC_LO = D0\nelif(S0 == 0)\n\t// done: executed low pass and skip high pass\n\tnop\nelse\n\t// execute second pass of two-pass mode\n\tEXEC_HI = D0\n\tD0 = EXEC_LO\n\tEXEC_LO = 0\n\tjump LABEL\nendif.\n```\nThis opcode is intended to be used in conjunction with S_SUBVECTOR_LOOP_BEGIN but there is no dedicated subvector state and internally it is equivalent to an S_CBRANCH with extra math. This opcode has well-defined semantics in wave32 mode but the author of this document is not aware of any practical wave32 programming scenario where it would make sense to use this opcode."
                }
            ]
        },
        {
            "key": "sop1",
            "name": "SOP1 Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "3",
                    "name": "S_MOV_B32",
                    "short": "Move data to an SGPR",
                    "description": "Move data to an SGPR.\n```\nD.u = S0.u.\n```"
                },
                {
                    "opcode": "4",
                    "name": "S_MOV_B64",
                    "short": "Move data to an SGPR",
                    "description": "Move data to an SGPR.\n```\nD.u64 = S0.u64.\n```"
                },
                {
                    "opcode": "5",
                    "name": "S_CMOV_B32",
                    "short": "Conditionally move data to an SGPR when scalar condition code is true",
                    "description": "Conditionally move data to an SGPR when scalar condition code is true.\n```\nif(SCC) then\n\tD.u = S0.u;\nendif.\n```"
                },
                {
                    "opcode": "6",
                    "name": "S_CMOV_B64",
                    "short": "Conditionally move data to an SGPR when scalar condition code is true",
                    "description": "Conditionally move data to an SGPR when scalar condition code is true.\n```\nif(SCC) then\n\tD.u64 = S0.u64;\nendif.\n```"
                },
                {
                    "opcode": "7",
                    "name": "S_NOT_B32",
                    "short": "Bitwise negation",
                    "description": "Bitwise negation.\n```\nD = ~S0;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "8",
                    "name": "S_NOT_B64",
                    "short": "Bitwise negation",
                    "description": "Bitwise negation.\n```\nD = ~S0;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "9",
                    "name": "S_WQM_B32",
                    "short": "Computes whole quad mode for an active/valid mask",
                    "description": "Computes whole quad mode for an active/valid mask. If any pixel in a quad is active, all pixels of the quad are marked active.\n```\nfor i in 0 ... opcode_size_in_bits - 1 do\n\tD[i] = (S0[(i & ~3):(i | 3)] != 0);\nendfor;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "10",
                    "name": "S_WQM_B64",
                    "short": "Computes whole quad mode for an active/valid mask",
                    "description": "Computes whole quad mode for an active/valid mask. If any pixel in a quad is active, all pixels of the quad are marked active.\n```\nfor i in 0 ... opcode_size_in_bits - 1 do\n\tD[i] = (S0[(i & ~3):(i | 3)] != 0);\nendfor;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "11",
                    "name": "S_BREV_B32",
                    "short": "Reverse bits",
                    "description": "Reverse bits.\n```\nD.u[31:0] = S0.u[0:31].\n```"
                },
                {
                    "opcode": "12",
                    "name": "S_BREV_B64",
                    "short": "Reverse bits",
                    "description": "Reverse bits.\n```\nD.u64[63:0] = S0.u64[0:63].\n```"
                },
                {
                    "opcode": "13",
                    "name": "S_BCNT0_I32_B32",
                    "short": "Count number of bits that are zero",
                    "description": "Count number of bits that are zero.\n```\nD = 0;\nfor i in 0 ... opcode_size_in_bits - 1 do\n\tD += (S0[i] == 0 ? 1 : 0)\nendfor;\nSCC = (D != 0).\n```\nFunctional examples:\n * S_BCNT0_I32_B32(0x00000000) => 32\n * S_BCNT0_I32_B32(0xcccccccc) => 16\n * S_BCNT0_I32_B32(0xffffffff) => 0"
                },
                {
                    "opcode": "14",
                    "name": "S_BCNT0_I32_B64",
                    "short": "Count number of bits that are zero",
                    "description": "Count number of bits that are zero.\n```\nD = 0;\nfor i in 0 ... opcode_size_in_bits - 1 do\n\tD += (S0[i] == 0 ? 1 : 0)\nendfor;\nSCC = (D != 0).\n```\nFunctional examples:\n * S_BCNT0_I32_B32(0x00000000) => 32\n * S_BCNT0_I32_B32(0xcccccccc) => 16\n * S_BCNT0_I32_B32(0xffffffff) => 0"
                },
                {
                    "opcode": "15",
                    "name": "S_BCNT1_I32_B32",
                    "short": "Count number of bits that are one",
                    "description": "Count number of bits that are one.\n```\nD = 0;\nfor i in 0 ... opcode_size_in_bits - 1 do\n\tD += (S0[i] == 1 ? 1 : 0)\nendfor;\nSCC = (D != 0).\n```\nFunctional examples:\n * S_BCNT1_I32_B32(0x00000000) => 0\n * S_BCNT1_I32_B32(0xcccccccc) => 16\n * S_BCNT1_I32_B32(0xffffffff) => 32"
                },
                {
                    "opcode": "16",
                    "name": "S_BCNT1_I32_B64",
                    "short": "Count number of bits that are one",
                    "description": "Count number of bits that are one.\n```\nD = 0;\nfor i in 0 ... opcode_size_in_bits - 1 do\n\tD += (S0[i] == 1 ? 1 : 0)\nendfor;\nSCC = (D != 0).\n```\nFunctional examples:\n * S_BCNT1_I32_B32(0x00000000) => 0\n * S_BCNT1_I32_B32(0xcccccccc) => 16\n * S_BCNT1_I32_B32(0xffffffff) => 32"
                },
                {
                    "opcode": "17",
                    "name": "S_FF0_I32_B32",
                    "short": "Returns the bit position of the first zero from the LSB (least significant bit), or -1 if there are no zeros",
                    "description": "Returns the bit position of the first zero from the LSB (least significant bit), or -1 if there are no zeros.\n```\nD.i = -1; // Set if no zeros are found\nfor i in 0 ... opcode_size_in_bits - 1 do // Search from LSB\n\tif S0[i] == 0 then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FF0_I32_B32(0xaaaaaaaa) => 0\n * S_FF0_I32_B32(0x55555555) => 1\n * S_FF0_I32_B32(0x00000000) => 0\n * S_FF0_I32_B32(0xffffffff) => 0xffffffff\n * S_FF0_I32_B32(0xfffeffff) => 16"
                },
                {
                    "opcode": "18",
                    "name": "S_FF0_I32_B64",
                    "short": "Returns the bit position of the first zero from the LSB (least significant bit), or -1 if there are no zeros",
                    "description": "Returns the bit position of the first zero from the LSB (least significant bit), or -1 if there are no zeros.\n```\nD.i = -1; // Set if no zeros are found\nfor i in 0 ... opcode_size_in_bits - 1 do // Search from LSB\n\tif S0[i] == 0 then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FF0_I32_B32(0xaaaaaaaa) => 0\n * S_FF0_I32_B32(0x55555555) => 1\n * S_FF0_I32_B32(0x00000000) => 0\n * S_FF0_I32_B32(0xffffffff) => 0xffffffff\n * S_FF0_I32_B32(0xfffeffff) => 16"
                },
                {
                    "opcode": "19",
                    "name": "S_FF1_I32_B32",
                    "short": "Returns the bit position of the first one from the LSB (least significant bit), or -1 if there are no ones",
                    "description": "Returns the bit position of the first one from the LSB (least significant bit), or -1 if there are no ones.\n```\nD.i = -1; // Set if no ones are found\nfor i in 0 ... opcode_size_in_bits - 1 do // Search from LSB\n\tif S0[i] == 1 then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FF1_I32_B32(0xaaaaaaaa) => 1\n * S_FF1_I32_B32(0x55555555) => 0\n * S_FF1_I32_B32(0x00000000) => 0xffffffff\n * S_FF1_I32_B32(0xffffffff) => 0\n * S_FF1_I32_B32(0x00010000) => 16"
                },
                {
                    "opcode": "20",
                    "name": "S_FF1_I32_B64",
                    "short": "Returns the bit position of the first one from the LSB (least significant bit), or -1 if there are no ones",
                    "description": "Returns the bit position of the first one from the LSB (least significant bit), or -1 if there are no ones.\n```\nD.i = -1; // Set if no ones are found\nfor i in 0 ... opcode_size_in_bits - 1 do // Search from LSB\n\tif S0[i] == 1 then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FF1_I32_B32(0xaaaaaaaa) => 1\n * S_FF1_I32_B32(0x55555555) => 0\n * S_FF1_I32_B32(0x00000000) => 0xffffffff\n * S_FF1_I32_B32(0xffffffff) => 0\n * S_FF1_I32_B32(0x00010000) => 16"
                },
                {
                    "opcode": "21",
                    "name": "S_FLBIT_I32_B32",
                    "short": "Counts how many zeros before the first one starting from the MSB (most significant bit)",
                    "description": "Counts how many zeros before the first one starting from the MSB (most significant bit). Returns -1 if there are no ones.\n```\nD.i = -1; // Set if no ones are found\nfor i in 0 ... opcode_size_in_bits - 1 do // Note: search is from the MSB\n\tif S0[opcode_size_in_bits - 1 - i] == 1 then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FLBIT_I32_B32(0x00000000) => 0xffffffff\n * S_FLBIT_I32_B32(0x0000cccc) => 16\n * S_FLBIT_I32_B32(0xffff3333) => 0\n * S_FLBIT_I32_B32(0x7fffffff) => 1\n * S_FLBIT_I32_B32(0x80000000) => 0\n * S_FLBIT_I32_B32(0xffffffff) => 0"
                },
                {
                    "opcode": "22",
                    "name": "S_FLBIT_I32_B64",
                    "short": "Counts how many zeros before the first one starting from the MSB (most significant bit)",
                    "description": "Counts how many zeros before the first one starting from the MSB (most significant bit). Returns -1 if there are no ones.\n```\nD.i = -1; // Set if no ones are found\nfor i in 0 ... opcode_size_in_bits - 1 do // Note: search is from the MSB\n\tif S0[opcode_size_in_bits - 1 - i] == 1 then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FLBIT_I32_B32(0x00000000) => 0xffffffff\n * S_FLBIT_I32_B32(0x0000cccc) => 16\n * S_FLBIT_I32_B32(0xffff3333) => 0\n * S_FLBIT_I32_B32(0x7fffffff) =>\n * 1 S_FLBIT_I32_B32(0x80000000) => 0\n * S_FLBIT_I32_B32(0xffffffff) => 0"
                },
                {
                    "opcode": "23",
                    "name": "S_FLBIT_I32",
                    "short": "Counts how many bits in a row (from MSB to LSB) are the same as the sign bit",
                    "description": "Counts how many bits in a row (from MSB to LSB) are the same as the sign bit. Returns -1 if all bits are the same.\n```\nD.i = -1; // Set if all bits are the same\nfor i in 1 ... opcode_size_in_bits - 1 do // Note: search is from the MSB\n\tif S0[opcode_size_in_bits - 1 - i] != S0[opcode_size_in_bits - 1] then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FLBIT_I32(0x00000000) => 0xffffffff\n * S_FLBIT_I32(0x0000cccc) => 16\n * S_FLBIT_I32(0xffff3333) => 16\n * S_FLBIT_I32(0x7fffffff) => 1\n * S_FLBIT_I32(0x80000000) => 1\n * S_FLBIT_I32(0xffffffff) => 0xffffffff"
                },
                {
                    "opcode": "24",
                    "name": "S_FLBIT_I32_I64",
                    "short": "Counts how many bits in a row (from MSB to LSB) are the same as the sign bit",
                    "description": "Counts how many bits in a row (from MSB to LSB) are the same as the sign bit. Returns -1 if all bits are the same.\n```\nD.i = -1; // Set if all bits are the same\nfor i in 1 ... opcode_size_in_bits - 1 do // Note: search is from the MSB\n\tif S0[opcode_size_in_bits - 1 - i] != S0[opcode_size_in_bits - 1] then\n\t\tD.i = i;\n\t\tbreak for;\n\tendif;\nendfor.\n```\nFunctional examples:\n * S_FLBIT_I32(0x00000000) => 0xffffffff\n * S_FLBIT_I32(0x0000cccc) => 16\n * S_FLBIT_I32(0xffff3333) => 16\n * S_FLBIT_I32(0x7fffffff) => 1\n * S_FLBIT_I32(0x80000000) => 1\n * S_FLBIT_I32(0xffffffff) => 0xffffffff"
                },
                {
                    "opcode": "25",
                    "name": "S_SEXT_I32_I8",
                    "short": "Sign extension of a signed byte",
                    "description": "Sign extension of a signed byte.\n```\nD.i = signext(S0.i[7:0]).\n```"
                },
                {
                    "opcode": "26",
                    "name": "S_SEXT_I32_I16",
                    "short": "Sign extension of a signed short",
                    "description": "Sign extension of a signed short.\n```\nD.i = signext(S0.i[15:0]).\n```"
                },
                {
                    "opcode": "27",
                    "name": "S_BITSET0_B32",
                    "short": "Set a specific bit to zero",
                    "description": "Set a specific bit to zero.\n```\nD.u[S0.u[4:0]] = 0.\n```"
                },
                {
                    "opcode": "28",
                    "name": "S_BITSET0_B64",
                    "short": "Set a specific bit to zero",
                    "description": "Set a specific bit to zero.\n```\nD.u64[S0.u[5:0]] = 0.\n```"
                },
                {
                    "opcode": "29",
                    "name": "S_BITSET1_B32",
                    "short": "Set a specific bit to one",
                    "description": "Set a specific bit to one.\n```\nD.u[S0.u[4:0]] = 1.\n```"
                },
                {
                    "opcode": "30",
                    "name": "S_BITSET1_B64",
                    "short": "Set a specific bit to one",
                    "description": "Set a specific bit to one.\n```\nD.u64[S0.u[5:0]] = 1.\n```"
                },
                {
                    "opcode": "31",
                    "name": "S_GETPC_B64",
                    "short": "Save current program location",
                    "description": "Save current program location. Destination receives the byte address of the next instruction.\n```\nD.u64 = PC + 4.\n```"
                },
                {
                    "opcode": "32",
                    "name": "S_SETPC_B64",
                    "short": "Jump to a new location",
                    "description": "Jump to a new location. S0.u64 is a byte address of the instruction to jump to.\n```\nPC = S0.u64.\n```"
                },
                {
                    "opcode": "33",
                    "name": "S_SWAPPC_B64",
                    "short": "Save current program location and jump to a new location",
                    "description": "Save current program location and jump to a new location. S0.u64 is a byte address of the instruction to jump to. Destination receives the byte address of the instruction immediately following the SWAPPC instruction.\n```\nD.u64 = PC + 4;\nPC = S0.u64.\n```"
                },
                {
                    "opcode": "34",
                    "name": "S_RFE_B64",
                    "short": "Return from exception handler and continue",
                    "description": "Return from exception handler and continue. This instruction may only be used within a trap handler.\n```\nPRIV = 0;\nPC = S0.u64.\n```"
                },
                {
                    "opcode": "36",
                    "name": "S_AND_SAVEEXEC_B64",
                    "short": "Bitwise AND with EXEC mask",
                    "description": "Bitwise AND with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = S0.u64 & EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "37",
                    "name": "S_OR_SAVEEXEC_B64",
                    "short": "Bitwise OR with EXEC mask",
                    "description": "Bitwise OR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = S0.u64 | EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "38",
                    "name": "S_XOR_SAVEEXEC_B64",
                    "short": "Bitwise XOR with EXEC mask",
                    "description": "Bitwise XOR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = S0.u64 ^ EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "39",
                    "name": "S_ANDN2_SAVEEXEC_B64",
                    "short": "Bitwise ANDN2 with EXEC mask",
                    "description": "Bitwise ANDN2 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = S0.u64 & ~EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "40",
                    "name": "S_ORN2_SAVEEXEC_B64",
                    "short": "Bitwise ORN2 with EXEC mask",
                    "description": "Bitwise ORN2 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = S0.u64 | ~EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "41",
                    "name": "S_NAND_SAVEEXEC_B64",
                    "short": "Bitwise NAND with EXEC mask",
                    "description": "Bitwise NAND with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = ~(S0.u64 & EXEC);\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "42",
                    "name": "S_NOR_SAVEEXEC_B64",
                    "short": "Bitwise NOR with EXEC mask",
                    "description": "Bitwise NOR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = ~(S0.u64 | EXEC);\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "43",
                    "name": "S_XNOR_SAVEEXEC_B64",
                    "short": "Bitwise XNOR with EXEC mask",
                    "description": "Bitwise XNOR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = ~(S0.u64 ^ EXEC);\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "44",
                    "name": "S_QUADMASK_B32",
                    "short": "Reduce a pixel mask to a quad mask",
                    "description": "Reduce a pixel mask to a quad mask. To perform the inverse operation see S_BITREPLICATE_B64_B32.\n```\nD = 0;\nfor i in 0 ... (opcode_size_in_bits / 4) - 1 do\n\tD[i] = (S0[i * 4 + 3:i * 4] != 0);\nendfor;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "45",
                    "name": "S_QUADMASK_B64",
                    "short": "Reduce a pixel mask to a quad mask",
                    "description": "Reduce a pixel mask to a quad mask. To perform the inverse operation see S_BITREPLICATE_B64_B32.\n```\nD = 0;\nfor i in 0 ... (opcode_size_in_bits / 4) - 1 do\n\tD[i] = (S0[i * 4 + 3:i * 4] != 0);\nendfor;\nSCC = (D != 0).\n```"
                },
                {
                    "opcode": "46",
                    "name": "S_MOVRELS_B32",
                    "short": "Move from a relative source address",
                    "description": "Move from a relative source address.\n```\nSGPR[D.addr].u32 = SGPR[S0.addr+M0[31:0]].u32\n```\nExample: The following instruction sequence will perform a move s5 <== s17:\n```\ns_mov_b32 m0, 10\ns_movrels_b32 s5, s7\n```"
                },
                {
                    "opcode": "47",
                    "name": "S_MOVRELS_B64",
                    "short": "Move from a relative source address",
                    "description": "Move from a relative source address. The index in M0.u must be even for this operation.\n```\nSGPR[D.addr].u64 = SGPR[S0.addr+M0[31:0]].u64\n```"
                },
                {
                    "opcode": "48",
                    "name": "S_MOVRELD_B32",
                    "short": "Move to a relative destination address",
                    "description": "Move to a relative destination address.\n```\nSGPR[D.addr+M0[31:0]].u32 = SGPR[S0.addr].u32\n```\nExample: The following instruction sequence will perform a move s15 <== s7:\n```\ns_mov_b32 m0, 10\ns_movreld_b32 s5, s7\n```"
                },
                {
                    "opcode": "49",
                    "name": "S_MOVRELD_B64",
                    "short": "Move to a relative destination address",
                    "description": "Move to a relative destination address. The index in M0.u must be even for this operation.\n```\nSGPR[D.addr+M0[31:0]].u64 = SGPR[S0.addr].u64\n```"
                },
                {
                    "opcode": "52",
                    "name": "S_ABS_I32",
                    "short": "Integer absolute value",
                    "description": "Integer absolute value.\n```\nD.i = (S.i < 0 ? -S.i : S.i);\nSCC = (D.i != 0).\n```\nFunctional examples:\n * S_ABS_I32(0x00000001) => 0x00000001\n * S_ABS_I32(0x7fffffff) => 0x7fffffff\n * S_ABS_I32(0x80000000) => 0x80000000// Note this is negative!\n * S_ABS_I32(0x80000001) => 0x7fffffff\n * S_ABS_I32(0x80000002) => 0x7ffffffe\n * S_ABS_I32(0xffffffff) => 0x00000001"
                },
                {
                    "opcode": "55",
                    "name": "S_ANDN1_SAVEEXEC_B64",
                    "short": "Bitwise ANDN1 with EXEC mask",
                    "description": "Bitwise ANDN1 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = ~S0.u64 & EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "56",
                    "name": "S_ORN1_SAVEEXEC_B64",
                    "short": "Bitwise ORN1 with EXEC mask",
                    "description": "Bitwise ORN1 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u64 = EXEC;\nEXEC = ~S0.u64 | EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "57",
                    "name": "S_ANDN1_WREXEC_B64",
                    "short": "Bitwise ANDN1 with EXEC mask",
                    "description": "Bitwise ANDN1 with EXEC mask. Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op result. EXEC and the destination SGPRs will have the same value at the end of this instruction. This instruction is intended to accelerate waterfalling.\n```\nEXEC = ~S0.u64 & EXEC;\nD.u64 = EXEC;\nSCC = (EXEC != 0).\n```"
                },
                {
                    "opcode": "58",
                    "name": "S_ANDN2_WREXEC_B64",
                    "short": "Bitwise ANDN2 with EXEC mask",
                    "description": "Bitwise ANDN2 with EXEC mask. Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op result. EXEC and the destination SGPRs will have the same value at the end of this instruction. This instruction is intended to accelerate waterfalling.\n```\nEXEC = S0.u64 & ~EXEC;\nD.u64 = EXEC;\nSCC = (EXEC != 0).\n```\nIn particular, the following sequence of waterfall code is optimized by using a WREXEC instead of two separate scalar ops:\n```\n// V0 holds the index value per lane\n// save exec mask for restore at the end\ns_mov_b64 s2, exec\n// exec mask of remaining (unprocessed) threads\ns_mov_b64 s4, exec\nloop:\n// get the index value for the first active lane\nv_readfirstlane_b32  s0, v0\n// find all other lanes with same index value\nv_cmpx_eq s0, v0\n<OP>// do the operation using the current EXEC mask. S0 holds the index.\n// mask out thread that was just executed\n// s_andn2_b64  s4, s4, exec\n// s_mov_b64exec, s4\ns_andn2_wrexec_b64 s4, s4// replaces above 2 ops\n// repeat until EXEC==0\ns_cbranch_scc1  loop\ns_mov_b64exec, s2\n```"
                },
                {
                    "opcode": "59",
                    "name": "S_BITREPLICATE_B64_B32",
                    "short": "Replicate the low 32 bits of S0 by 'doubling' each bit",
                    "description": "Replicate the low 32 bits of S0 by 'doubling' each bit.\n```\nfor i in 0 ... 31 do\n\tD.u64[i * 2 + 0] = S0.u32[i]\n\tD.u64[i * 2 + 1] = S0.u32[i]\nendfor.\n```\nThis opcode can be used to convert a quad mask into a pixel mask; given quad mask in s0, the following sequence will produce a pixel mask in s2:\n```\ns_bitreplicate_b64 s2, s0\ns_bitreplicate_b64 s2, s2\n```\nTo perform the inverse operation see S_QUADMASK_B64."
                },
                {
                    "opcode": "60",
                    "name": "S_AND_SAVEEXEC_B32",
                    "short": "Bitwise AND with EXEC mask",
                    "description": "Bitwise AND with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = S0.u32 & EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "61",
                    "name": "S_OR_SAVEEXEC_B32",
                    "short": "Bitwise OR with EXEC mask",
                    "description": "Bitwise OR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = S0.u32 | EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "62",
                    "name": "S_XOR_SAVEEXEC_B32",
                    "short": "Bitwise XOR with EXEC mask",
                    "description": "Bitwise XOR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = S0.u32 ^ EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "63",
                    "name": "S_ANDN2_SAVEEXEC_B32",
                    "short": "Bitwise ANDN2 with EXEC mask",
                    "description": "Bitwise ANDN2 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = S0.u32 & ~EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "64",
                    "name": "S_ORN2_SAVEEXEC_B32",
                    "short": "Bitwise ORN2 with EXEC mask",
                    "description": "Bitwise ORN2 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = S0.u32 | ~EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "65",
                    "name": "S_NAND_SAVEEXEC_B32",
                    "short": "Bitwise NAND with EXEC mask",
                    "description": "Bitwise NAND with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = ~(S0.u32 & EXEC_LO);\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "66",
                    "name": "S_NOR_SAVEEXEC_B32",
                    "short": "Bitwise NOR with EXEC mask",
                    "description": "Bitwise NOR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = ~(S0.u32 | EXEC_LO);\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "67",
                    "name": "S_XNOR_SAVEEXEC_B32",
                    "short": "Bitwise XNOR with EXEC mask",
                    "description": "Bitwise XNOR with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = ~(S0.u32 ^ EXEC_LO);\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "68",
                    "name": "S_ANDN1_SAVEEXEC_B32",
                    "short": "Bitwise ANDN1 with EXEC mask",
                    "description": "Bitwise ANDN1 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = ~S0.u32 & EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "69",
                    "name": "S_ORN1_SAVEEXEC_B32",
                    "short": "Bitwise ORN1 with EXEC mask",
                    "description": "Bitwise ORN1 with EXEC mask. The original EXEC mask is saved to the destination SGPRs before the bitwise operation is performed.\n```\nD.u32 = EXEC_LO;\nEXEC_LO = ~S0.u32 | EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "70",
                    "name": "S_ANDN1_WREXEC_B32",
                    "short": "Bitwise ANDN1 with EXEC mask",
                    "description": "Bitwise ANDN1 with EXEC mask. Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op result. EXEC and the destination SGPRs will have the same value at the end of this instruction. This instruction is intended to accelerate waterfalling.\n```\nEXEC_LO = ~S0.u32 & EXEC_LO;\nD.u32 = EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "71",
                    "name": "S_ANDN2_WREXEC_B32",
                    "short": "Bitwise ANDN2 with EXEC mask",
                    "description": "Bitwise ANDN2 with EXEC mask. Unlike the SAVEEXEC series of opcodes, the value written to destination SGPRs is the result of the bitwise-op result. EXEC and the destination SGPRs will have the same value at the end of this instruction. This instruction is intended to accelerate waterfalling. See S_ANDN2_WREXEC_B64 for example code.\n```\nEXEC_LO = S0.u32 & ~EXEC_LO;\nD.u32 = EXEC_LO;\nSCC = (EXEC_LO != 0).\n```"
                },
                {
                    "opcode": "73",
                    "name": "S_MOVRELSD_2_B32",
                    "short": "Move from a relative source address to a relative destination address, with different offsets",
                    "description": "Move from a relative source address to a relative destination address, with different offsets.\n```\nSGPR[D.addr+M0[25:16]].u32 = SGPR[S0.addr+M0[9:0]].u32\n```\nExample: The following instruction sequence will perform a move s25 <== s17:\n```\ns_mov_b32 m0, ((20 << 16) | 10)\ns_movrelsd_2_b32 s5, s7\n```\n"
                }
            ]
        },
        {
            "key": "sopc",
            "name": "SOPC Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "S_CMP_EQ_I32",
                    "short": "Compare two integers for equality",
                    "description": "Compare two integers for equality. Note that S_CMP_EQ_I32 and S_CMP_EQ_U32 are identical opcodes, but both are provided for symmetry.\n```\nSCC = (S0 == S1).\n```"
                },
                {
                    "opcode": "1",
                    "name": "S_CMP_LG_I32",
                    "short": "Compare two integers for inequality",
                    "description": "Compare two integers for inequality. Note that S_CMP_LG_I32 and S_CMP_LG_U32 are identical opcodes, but both are provided for symmetry.\n```\nSCC = (S0 != S1).\n```"
                },
                {
                    "opcode": "2",
                    "name": "S_CMP_GT_I32",
                    "short": "SCC = (S0.i > S1.i)",
                    "description": "```\nSCC = (S0.i > S1.i).\n```"
                },
                {
                    "opcode": "3",
                    "name": "S_CMP_GE_I32",
                    "short": "SCC = (S0.i >= S1.i)",
                    "description": "```\nSCC = (S0.i >= S1.i).\n```"
                },
                {
                    "opcode": "4",
                    "name": "S_CMP_LT_I32",
                    "short": "SCC = (S0.i < S1.i)",
                    "description": "```\nSCC = (S0.i < S1.i).\n```"
                },
                {
                    "opcode": "5",
                    "name": "S_CMP_LE_I32",
                    "short": "SCC = (S0.i <= S1.i)",
                    "description": "```\nSCC = (S0.i <= S1.i).\n```"
                },
                {
                    "opcode": "6",
                    "name": "S_CMP_EQ_U32",
                    "short": "Compare two integers for equality",
                    "description": "Compare two integers for equality. Note that S_CMP_EQ_I32 and S_CMP_EQ_U32 are identical opcodes, but both are provided for symmetry.\n```\nSCC = (S0 == S1).\n```"
                },
                {
                    "opcode": "7",
                    "name": "S_CMP_LG_U32",
                    "short": "Compare two integers for inequality",
                    "description": "Compare two integers for inequality. Note that S_CMP_LG_I32 and S_CMP_LG_U32 are identical opcodes, but both are provided for symmetry.\n```\nSCC = (S0 != S1).\n```"
                },
                {
                    "opcode": "8",
                    "name": "S_CMP_GT_U32",
                    "short": "SCC = (S0.u > S1.u)",
                    "description": "```\nSCC = (S0.u > S1.u).\n```"
                },
                {
                    "opcode": "9",
                    "name": "S_CMP_GE_U32",
                    "short": "SCC = (S0.u >= S1.u)",
                    "description": "```\nSCC = (S0.u >= S1.u).\n```"
                },
                {
                    "opcode": "10",
                    "name": "S_CMP_LT_U32",
                    "short": "SCC = (S0.u < S1.u)",
                    "description": "```\nSCC = (S0.u < S1.u).\n```"
                },
                {
                    "opcode": "11",
                    "name": "S_CMP_LE_U32",
                    "short": "SCC = (S0.u <= S1.u)",
                    "description": "```\nSCC = (S0.u <= S1.u).\n```"
                },
                {
                    "opcode": "12",
                    "name": "S_BITCMP0_B32",
                    "short": "SCC = (S0.u[S1.u[4:0]] == 0)",
                    "description": "```\nSCC = (S0.u[S1.u[4:0]] == 0).\n```"
                },
                {
                    "opcode": "13",
                    "name": "S_BITCMP1_B32",
                    "short": "SCC = (S0.u[S1.u[4:0]] == 1)",
                    "description": "```\nSCC = (S0.u[S1.u[4:0]] == 1).\n```"
                },
                {
                    "opcode": "14",
                    "name": "S_BITCMP0_B64",
                    "short": "SCC = (S0.u64[S1.u[5:0]] == 0)",
                    "description": "```\nSCC = (S0.u64[S1.u[5:0]] == 0).\n```"
                },
                {
                    "opcode": "15",
                    "name": "S_BITCMP1_B64",
                    "short": "SCC = (S0.u64[S1.u[5:0]] == 1)",
                    "description": "```\nSCC = (S0.u64[S1.u[5:0]] == 1).\n```"
                },
                {
                    "opcode": "18",
                    "name": "S_CMP_EQ_U64",
                    "short": "SCC = (S0.i64 == S1.i64)",
                    "description": "```\nSCC = (S0.i64 == S1.i64).\n```"
                },
                {
                    "opcode": "19",
                    "name": "S_CMP_LG_U64",
                    "short": "SCC = (S0.i64 != S1.i64)",
                    "description": "```\nSCC = (S0.i64 != S1.i64).\n```"
                }
            ]
        },
        {
            "key": "sopp",
            "name": "SOPP Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "S_NOP",
                    "short": "Do nothing",
                    "description": "Do nothing. Repeat NOP 1..16 times based on SIMM16[3:0] -- 0x0 = 1 time, 0xf = 16 times. Examples: s_nop 0        // Wait 1 cycle. s_nop 0xf      // Wait 16 cycles."
                },
                {
                    "opcode": "1",
                    "name": "S_ENDPGM",
                    "short": "End of program; terminate wavefront",
                    "description": "End of program; terminate wavefront.  The hardware implicitly executes S_WAITCNT 0 and S_WAITCNT_VSCNT 0 before executing this instruction.  See S_ENDPGM_SAVED for the context-switch version of this instruction and S_ENDPGM_ORDERED_PS_DONE for the POPS critical region version of this instruction."
                },
                {
                    "opcode": "2",
                    "name": "S_BRANCH",
                    "short": "Perform an unconditional short jump",
                    "description": "Perform an unconditional short jump.  For a long jump, use S_SETPC_B64. PC = PC + signext(SIMM16 * 4) + 4. // short jump. Examples: s_branch label   // Set SIMM16 = +4 = 0x0004 s_nop 0   // 4 bytes label: s_nop 0   // 4 bytes s_branch label   // Set SIMM16 = -8 = 0xfff8"
                },
                {
                    "opcode": "3",
                    "name": "S_WAKEUP",
                    "short": "Allow a wave to 'ping' all the other waves in its threadgroup to force them to wake up early from an S_SLEEP instruction",
                    "description": "Allow a wave to 'ping' all the other waves in its threadgroup to force them to wake up early from an S_SLEEP instruction. The ping is ignored if the waves are not sleeping.  This allows for efficient polling on a memory location. The waves which are polling can sit in a long S_SLEEP between memory reads, but the wave which writes the value can tell them all to wake up early now that the data is available. This is useful for fBarrier implementations (speedup).  This method is also safe from races because if any wave misses the ping, everything still works fine (waves which missed it just complete their S_SLEEP). If the wave executing S_WAKEUP is in a threadgroup (in_tg set), then it will wake up all waves associated with the same threadgroup ID. Otherwise, S_WAKEUP is treated as an S_NOP."
                },
                {
                    "opcode": "4",
                    "name": "S_CBRANCH_SCC0",
                    "short": "Perform a conditional short jump when SCC is zero",
                    "description": "Perform a conditional short jump when SCC is zero. if(SCC == 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "5",
                    "name": "S_CBRANCH_SCC1",
                    "short": "Perform a conditional short jump when SCC is one",
                    "description": "Perform a conditional short jump when SCC is one. if(SCC == 1) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "6",
                    "name": "S_CBRANCH_VCCZ",
                    "short": "Perform a conditional short jump when VCC is zero",
                    "description": "Perform a conditional short jump when VCC is zero. if(VCC == 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "7",
                    "name": "S_CBRANCH_VCCNZ",
                    "short": "Perform a conditional short jump when VCC is nonzero",
                    "description": "Perform a conditional short jump when VCC is nonzero. if(VCC != 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "8",
                    "name": "S_CBRANCH_EXECZ",
                    "short": "Perform a conditional short jump when EXEC is zero",
                    "description": "Perform a conditional short jump when EXEC is zero. if(EXEC == 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "9",
                    "name": "S_CBRANCH_EXECNZ",
                    "short": "Perform a conditional short jump when EXEC is nonzero",
                    "description": "Perform a conditional short jump when EXEC is nonzero. if(EXEC != 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "10",
                    "name": "S_BARRIER",
                    "short": "Synchronize waves within a threadgroup",
                    "description": "Synchronize waves within a threadgroup.  If not all waves of the threadgroup have been created yet, waits for entire group before proceeding.  If some waves in the threadgroup have already terminated, this waits on only the surviving waves.  Barriers are legal inside trap handlers."
                },
                {
                    "opcode": "11",
                    "name": "S_SETKILL",
                    "short": "Set KILL bit to value of SIMM16[0]",
                    "description": "Set KILL bit to value of SIMM16[0].  Used primarily for debugging kill wave host command behavior."
                },
                {
                    "opcode": "12",
                    "name": "S_WAITCNT",
                    "short": "Wait for the counts of outstanding lds, vector-memory and export/vmem-write-data to be at or below the specified levels",
                    "description": "Wait for the counts of outstanding lds, vector-memory and export/vmem-write-data to be at or below the specified levels. Waits for all of the following conditions to hold before continuing: vmcnt <= {SIMM16[15:14], SIMM16[3:0]} expcnt <= SIMM16[6:4] lgkmcnt <= SIMM16[13:8] NOTE: VMCNT only counts vector memory loads, image sample instructions, and vector memory atomics that return data.  Contrast with the VSCNT counter. See also S_WAITCNT_VSCNT."
                },
                {
                    "opcode": "13",
                    "name": "S_SETHALT",
                    "short": "S_SETHALT can set/clear the HALT or FATAL_HALT status bits",
                    "description": "S_SETHALT can set/clear the HALT or FATAL_HALT status bits.  The particular status bit is chosen by halt type control as indicated in SIMM16[2]; 0 = HALT bit select; 1 = FATAL_HALT bit select. When halt type control is set to 0 = HALT bit select: Set HALT bit to value of SIMM16[0]; 1 = halt, 0 = clear HALT bit. The halt flag is ignored while PRIV == 1 (inside trap handlers) but the shader will halt after the handler returns if HALT is still set at that time. When halt type control is set to 1 = FATAL HALT bit select: Set FATAL_HALT bit to value of SIMM16[0]; 1 = fatal_halt, 0 = clear FATAL_HALT bit.  Setting the fatal_halt flag halts the shader in or outside of the trap handlers."
                },
                {
                    "opcode": "14",
                    "name": "S_SLEEP",
                    "short": "Cause a wave to sleep for (64*(SIMM16[6:0]-1) ",
                    "description": "Cause a wave to sleep for (64*(SIMM16[6:0]-1) .. 64*SIMM16[6:0]) clocks.  The exact amount of delay is approximate.  Compare with S_NOP.  When SIMM16[6:0] is zero then no sleep occurs. Examples: s_sleep 0      // Wait for 0 clocks. s_sleep 1      // Wait for 1-64 clocks. s_sleep 2      // Wait for 65-128 clocks."
                },
                {
                    "opcode": "15",
                    "name": "S_SETPRIO",
                    "short": "User settable wave priority is set to SIMM16[1:0]",
                    "description": "User settable wave priority is set to SIMM16[1:0]. 0 = lowest, 3 = highest.  The overall wave priority is {SPIPrio[1:0] + UserPrio[1:0], WaveAge[3:0]}."
                },
                {
                    "opcode": "16",
                    "name": "S_SENDMSG",
                    "short": "Send a message upstream to VGT or the interrupt handler",
                    "description": "Send a message upstream to VGT or the interrupt handler. SIMM16[9:0] contains the message type."
                },
                {
                    "opcode": "17",
                    "name": "S_SENDMSGHALT",
                    "short": "Send a message and then HALT the wavefront; see S_SENDMSG for details",
                    "description": "Send a message and then HALT the wavefront; see S_SENDMSG for details."
                },
                {
                    "opcode": "18",
                    "name": "S_TRAP",
                    "short": "Enter the trap handler",
                    "description": "Enter the trap handler.  This instruction may be generated internally as well in response to a host trap (HT = 1) or an exception.  TrapID 0 is reserved for hardware use and should not be used in a shader-generated trap. TrapID = SIMM16[7:0]; Wait for all instructions to complete; {TTMP1, TTMP0} = {1'h0, PCRewind[5:0], HT[0], TrapID[7:0], PC[47:0]}; PC = TBA; // trap base address PRIV = 1."
                },
                {
                    "opcode": "19",
                    "name": "S_ICACHE_INV",
                    "short": "Invalidate entire L0 instruction cache",
                    "description": "Invalidate entire L0 instruction cache. The hardware invalidates the instruction buffer, so no S_NOP instructions are required after S_ICACHE_INV."
                },
                {
                    "opcode": "20",
                    "name": "S_INCPERFLEVEL",
                    "short": "Increment performance counter specified in SIMM16[3:0] by 1",
                    "description": "Increment performance counter specified in SIMM16[3:0] by 1."
                },
                {
                    "opcode": "21",
                    "name": "S_DECPERFLEVEL",
                    "short": "Decrement performance counter specified in SIMM16[3:0] by 1",
                    "description": "Decrement performance counter specified in SIMM16[3:0] by 1."
                },
                {
                    "opcode": "22",
                    "name": "S_TTRACEDATA",
                    "short": "Send M0 as user data to the thread trace stream",
                    "description": "Send M0 as user data to the thread trace stream."
                },
                {
                    "opcode": "23",
                    "name": "S_CBRANCH_CDBGSYS",
                    "short": " Perform a conditional short jump when the system debug flag is set",
                    "description": " Perform a conditional short jump when the system debug flag is set. if(conditional_debug_system != 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "24",
                    "name": "S_CBRANCH_CDBGUSER",
                    "short": " Perform a conditional short jump when the user debug flag is set",
                    "description": " Perform a conditional short jump when the user debug flag is set. if(conditional_debug_user != 0) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "25",
                    "name": "S_CBRANCH_CDBGSYS_OR_USER",
                    "short": " Perform a conditional short jump when either the system or the user debug flag are set",
                    "description": " Perform a conditional short jump when either the system or the user debug flag are set. if(conditional_debug_system || conditional_debug_user) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "26",
                    "name": "S_CBRANCH_CDBGSYS_AND_USER",
                    "short": " Perform a conditional short jump when both the system and the user debug flag are set",
                    "description": " Perform a conditional short jump when both the system and the user debug flag are set. if(conditional_debug_system && conditional_debug_user) then PC = PC + signext(SIMM16 * 4) + 4; endif."
                },
                {
                    "opcode": "27",
                    "name": "S_ENDPGM_SAVED",
                    "short": "End of program; signal that a wave has been saved by the context-switch trap handler and terminate wavefront",
                    "description": "End of program; signal that a wave has been saved by the context-switch trap handler and terminate wavefront.  The hardware implicitly executes S_WAITCNT 0 and S_WAITCNT_VSCNT 0 before executing this instruction.  See S_ENDPGM for additional variants."
                },
                {
                    "opcode": "30",
                    "name": "S_ENDPGM_ORDERED_PS_DONE",
                    "short": " End of program; signal that a wave has exited its POPS critical section and terminate wavefront",
                    "description": " End of program; signal that a wave has exited its POPS critical section and terminate wavefront.  The hardware implicitly executes S_WAITCNT 0 and S_WAITCNT_VSCNT 0 before executing this instruction. This instruction is an optimization that combines S_SENDMSG(MSG_ORDERED_PS_DONE) and S_ENDPGM; there may be cases where you still need to send the message separately, in which case the shader must end with a regular S_ENDPGM instruction. See S_ENDPGM for additional variants."
                },
                {
                    "opcode": "31",
                    "name": "S_CODE_END",
                    "short": "Generate an illegal instruction interrupt",
                    "description": "Generate an illegal instruction interrupt. This instruction should NEVER appear in typical shader code.  It is used to pad the end of a shader program to make it easier for analysis programs to locate the end of a shader program buffer. Use of this opcode in an embedded shader block may cause analysis tools to fail. To unambiguously mark the end of a shader buffer, this instruction must be specified five times in a row (total of 20 bytes) and analysis tools must ensure the opcode occurs at least five times to be certain they are at the end of the buffer. This is because the bit pattern generated by this opcode could incidentally appear in a valid instruction's second dword, literal constant or as part of a multi-DWORD image instruction. In short: do not embed this opcode in the middle of a valid shader program. DO use this opcode 5 times at the end of a shader program to clearly mark the end of the program. Example: ... s_endpgm       // last real instruction in shader buffer s_code_end     // 1 s_code_end     // 2 s_code_end     // 3 s_code_end     // 4 s_code_end     // done!"
                },
                {
                    "opcode": "32",
                    "name": "S_INST_PREFETCH",
                    "short": "Change instruction prefetch mode",
                    "description": "Change instruction prefetch mode. SIMM16[1:0] specifies the prefetch mode to switch to. Defined prefetch modes are: 0: reserved 1: SQ_PREFETCH_1_LINE -- prefetch 1 line 2: SQ_PREFETCH_2_LINES -- prefetch 2 lines 3: SQ_PREFETCH_3_LINES -- prefetch 3 lines SIMM16[15:2] must be set to zero."
                },
                {
                    "opcode": "33",
                    "name": "S_CLAUSE",
                    "short": "Mark the beginning of a clause",
                    "description": "Mark the beginning of a clause. The next instruction determines the clause type, which may be one of the following types. Texture, Buffer, Global, Scratch (clause may not mix atomics, loads & stores) Flat (loads, stores and atomics may not be combined in a clause) LDS SMEM VALU Halting and killing a wave will break the clause. The clause length is: (SIMM16[5:0] + 1), and clauses must be 2 instructions or longer and no more than 63 instructions. SIMM16[11:8] determines the number of instructions per clause break, in the range 0..15. If SIMM16[11:8] == 0 then there are no clause breaks. The following instruction types cannot appear in a clause: SALU Export Branch Message GDS"
                },
                {
                    "opcode": "35",
                    "name": "S_WAITCNT_DEPCTR",
                    "short": "Bit mask of which dependency counters to wait to be zero, intended for debug and bug-workarounds",
                    "description": "Bit mask of which dependency counters to wait to be zero, intended for debug and bug-workarounds. Waits for all of the following conditions to hold before continuing: va_vdst <= SIMM16[15:12] || SIMM16[15:12] == 0xf va_sdst <= SIMM16[11:9] || SIMM16[11:9] == 0x7 va_ssrc == 0 || SIMM16[8] == 1 hold_cnt == 0 || SIMM16[7] == 1 vm_vsrc <= SIMM16[4:2] || SIMM16[4:2] == 0x7 va_vcc == 0 || SIMM16[1] == 1 sa_sdst == 0 || SIMM16[0] == 1 Some wait values are smaller than the counters: the max wait value means don't wait on this counter.  For example, VM_VSRC is 4 bits, but the wait field for VM_VSRC is only 3 bits.  The value 7 means don't wait on VM_VSRC, 6 means wait for VM_VSRC <= 6, etc.  The wait value for VA_VCC is just 1 bit even though the counter is 3 bits: 0 = wait for va_vcc==0, 1 = don't wait on va_vcc."
                },
                {
                    "opcode": "36",
                    "name": "S_ROUND_MODE",
                    "short": "Set floating point round mode using an immediate constant",
                    "description": "Set floating point round mode using an immediate constant. Avoids wait state penalty that would be imposed by S_SETREG."
                },
                {
                    "opcode": "37",
                    "name": "S_DENORM_MODE",
                    "short": "Set floating point denormal mode using an immediate constant",
                    "description": "Set floating point denormal mode using an immediate constant. Avoids wait state penalty that would be imposed by S_SETREG."
                },
                {
                    "opcode": "40",
                    "name": "S_TTRACEDATA_IMM",
                    "short": "Send SIMM16[7:0] as user data to the thread trace stream",
                    "description": "Send SIMM16[7:0] as user data to the thread trace stream. 2=emit"
                }
            ]
        },
        {
            "key": "smem",
            "name": "SMEM Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "S_LOAD_DWORD",
                    "short": "Read 1 dword from scalar data cache",
                    "description": "Read 1 dword from scalar data cache. If the offset is specified as an SGPR, the SGPR contains an UNSIGNED BYTE offset (the 2 LSBs are ignored). If the offset is specified as an immediate 21-bit constant, the constant is a SIGNED BYTE offset."
                },
                {
                    "opcode": "1",
                    "name": "S_LOAD_DWORDX2",
                    "short": "Read 2 dwords from scalar data cache",
                    "description": "Read 2 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "2",
                    "name": "S_LOAD_DWORDX4",
                    "short": "Read 4 dwords from scalar data cache",
                    "description": "Read 4 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "3",
                    "name": "S_LOAD_DWORDX8",
                    "short": "Read 8 dwords from scalar data cache",
                    "description": "Read 8 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "4",
                    "name": "S_LOAD_DWORDX16",
                    "short": "Read 16 dwords from scalar data cache",
                    "description": "Read 16 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "8",
                    "name": "S_BUFFER_LOAD_DWORD",
                    "short": "Read 1 dword from scalar data cache",
                    "description": "Read 1 dword from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "9",
                    "name": "S_BUFFER_LOAD_DWORDX2",
                    "short": "Read 2 dwords from scalar data cache",
                    "description": "Read 2 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "10",
                    "name": "S_BUFFER_LOAD_DWORDX4",
                    "short": "Read 4 dwords from scalar data cache",
                    "description": "Read 4 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "11",
                    "name": "S_BUFFER_LOAD_DWORDX8",
                    "short": "Read 8 dwords from scalar data cache",
                    "description": "Read 8 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "12",
                    "name": "S_BUFFER_LOAD_DWORDX16",
                    "short": "Read 16 dwords from scalar data cache",
                    "description": "Read 16 dwords from scalar data cache. See S_LOAD_DWORD for details on the offset input."
                },
                {
                    "opcode": "31",
                    "name": "S_GL1_INV",
                    "short": "Invalidate the GL1 cache only",
                    "description": "Invalidate the GL1 cache only."
                },
                {
                    "opcode": "32",
                    "name": "S_DCACHE_INV",
                    "short": "Invalidate the scalar data L0 cache",
                    "description": "Invalidate the scalar data L0 cache."
                },
                {
                    "opcode": "36",
                    "name": "S_MEMTIME",
                    "short": "Return current 64-bit timestamp",
                    "description": "Return current 64-bit timestamp."
                },
                {
                    "opcode": "37",
                    "name": "S_MEMREALTIME",
                    "short": "Return current 64-bit RTC",
                    "description": "Return current 64-bit RTC."
                },
                {
                    "opcode": "38",
                    "name": "S_ATC_PROBE",
                    "short": "Probe or prefetch an address into the SQC data cache",
                    "description": "Probe or prefetch an address into the SQC data cache."
                },
                {
                    "opcode": "39",
                    "name": "S_ATC_PROBE_BUFFER",
                    "short": "Probe or prefetch an address into the SQC data cache",
                    "description": "Probe or prefetch an address into the SQC data cache."
                }
            ]
        },
        {
            "key": "vop2",
            "name": "VOP2 Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "1",
                    "name": "V_CNDMASK_B32",
                    "short": "Conditional mask on each thread",
                    "description": "Conditional mask on each thread. In VOP3 the VCC source may be a scalar GPR specified in S2.u. Floating-point modifiers are valid for this instruction if S0.u and S1.u are 32-bit floating point values. This instruction is suitable for negating or taking the absolute value of a floating-point value. D.u32 = VCC ? S1.u32 : S0.u32."
                },
                {
                    "opcode": "2",
                    "name": "V_DOT2C_F32_F16",
                    "short": "Dot product of packed FP16 values, accumulate with destination",
                    "description": "Dot product of packed FP16 values, accumulate with destination. D.f32 = S0.f16[0] * S1.f16[0] + S0.f16[1] * S1.f16[1] + D.f32."
                },
                {
                    "opcode": "3",
                    "name": "V_ADD_F32",
                    "short": "Add two single-precision values",
                    "description": "Add two single-precision values.  0.5ULP precision, denormals are supported. D.f32 = S0.f32 + S1.f32."
                },
                {
                    "opcode": "4",
                    "name": "V_SUB_F32",
                    "short": "Subtract the second single-precision input from the first input",
                    "description": "Subtract the second single-precision input from the first input. D.f32 = S0.f32 - S1.f32."
                },
                {
                    "opcode": "5",
                    "name": "V_SUBREV_F32",
                    "short": "Subtract the first single-precision input from the second input",
                    "description": "Subtract the first single-precision input from the second input. D.f32 = S1.f32 - S0.f32."
                },
                {
                    "opcode": "6",
                    "name": "V_FMAC_LEGACY_F32",
                    "short": "Multiply two single-precision values and accumulate the result with the destination",
                    "description": "Multiply two single-precision values and accumulate the result with the destination.  Follows DX9 rules where 0.0 times anything produces 0.0 (this is not IEEE compliant). D.f32 = S0.f32 * S1.f32 + S2.f32. // DX9 rules, 0.0 * x = 0.0"
                },
                {
                    "opcode": "7",
                    "name": "V_MUL_LEGACY_F32",
                    "short": "Multiply two single-precision values",
                    "description": "Multiply two single-precision values.  Follows DX9 rules where 0.0 times anything produces 0.0 (this is not IEEE compliant). D.f32 = S0.f32 * S1.f32. // DX9 rules, 0.0*x = 0.0"
                },
                {
                    "opcode": "8",
                    "name": "V_MUL_F32",
                    "short": "Multiply two single-precision values",
                    "description": "Multiply two single-precision values.  0.5ULP precision, denormals are supported. D.f32 = S0.f32 * S1.f32."
                },
                {
                    "opcode": "9",
                    "name": "V_MUL_I32_I24",
                    "short": "Multiply two signed 24-bit integers and store the result as a signed 32-bit integer",
                    "description": "Multiply two signed 24-bit integers and store the result as a signed 32-bit integer.  This opcode is as efficient as basic single-precision opcodes since it utilizes the single-precision floating point multiplier.  See also V_MUL_HI_I32_I24. D.i32 = S0.i24 * S1.i24."
                },
                {
                    "opcode": "10",
                    "name": "V_MUL_HI_I32_I24",
                    "short": "Multiply two signed 24-bit integers and store the high 32 bits of the result as a signed 32-bit integer",
                    "description": "Multiply two signed 24-bit integers and store the high 32 bits of the result as a signed 32-bit integer.  See also V_MUL_I32_I24. D.i32 = (S0.i24 * S1.i24)>>32;"
                },
                {
                    "opcode": "11",
                    "name": "V_MUL_U32_U24",
                    "short": "Multiply two unsigned 24-bit integers and store the result as an unsigned 32-bit integer",
                    "description": "Multiply two unsigned 24-bit integers and store the result as an unsigned 32-bit integer.  This opcode is as efficient as basic single-precision opcodes since it utilizes the single-precision floating point multiplier.  See also V_MUL_HI_U32_U24. D.u32 = S0.u24 * S1.u24."
                },
                {
                    "opcode": "12",
                    "name": "V_MUL_HI_U32_U24",
                    "short": "Multiply two unsigned 24-bit integers and store the high 32 bits of the result as an unsigned 32-bit integer",
                    "description": "Multiply two unsigned 24-bit integers and store the high 32 bits of the result as an unsigned 32-bit integer.  See also V_MUL_U32_U24. D.u32 = (S0.u24 * S1.u24)>>32."
                },
                {
                    "opcode": "13",
                    "name": "V_DOT4C_I32_I8",
                    "short": "Dot product of packed byte values, accumulate with destination",
                    "description": "Dot product of packed byte values, accumulate with destination. D.i32 = S0.i8[0] * S1.i8[0] + S0.i8[1] * S1.i8[1] + S0.i8[2] * S1.i8[2] + S0.i8[3] * S1.i8[3] + D.i32."
                },
                {
                    "opcode": "15",
                    "name": "V_MIN_F32",
                    "short": "Compute the minimum of two single-precision floats",
                    "description": "Compute the minimum of two single-precision floats. D.f32 = min(S0.f32,S1.f32); if (IEEE_MODE && S0.f == sNaN) D.f = Quiet(S0.f); else if (IEEE_MODE && S1.f == sNaN) D.f = Quiet(S1.f); else if (S0.f == NaN) D.f = S1.f; else if (S1.f == NaN) D.f = S0.f; else if (S0.f == +0.0 && S1.f == -0.0) D.f = S1.f; else if (S0.f == -0.0 && S1.f == +0.0) D.f = S0.f; else // Note: there's no IEEE special case here like there is for V_MAX_F32. D.f = (S0.f < S1.f ? S0.f : S1.f); endif."
                },
                {
                    "opcode": "16",
                    "name": "V_MAX_F32",
                    "short": "Compute the maximum of two single-precision floats",
                    "description": "Compute the maximum of two single-precision floats. D.f32 = max(S0.f32,S1.f32); if (IEEE_MODE && S0.f == sNaN) D.f = Quiet(S0.f); else if (IEEE_MODE && S1.f == sNaN) D.f = Quiet(S1.f); else if (S0.f == NaN) D.f = S1.f; else if (S1.f == NaN) D.f = S0.f; else if (S0.f == +0.0 && S1.f == -0.0) D.f = S0.f; else if (S0.f == -0.0 && S1.f == +0.0) D.f = S1.f; else if (IEEE_MODE) D.f = (S0.f >= S1.f ? S0.f : S1.f); else D.f = (S0.f > S1.f ? S0.f : S1.f); endif."
                },
                {
                    "opcode": "17",
                    "name": "V_MIN_I32",
                    "short": "Compute the minimum of two signed integers",
                    "description": "Compute the minimum of two signed integers. D.i32 = (S0.i32 < S1.i32 ? S0.i32 : S1.i32)."
                },
                {
                    "opcode": "18",
                    "name": "V_MAX_I32",
                    "short": "Compute the maximum of two signed integers",
                    "description": "Compute the maximum of two signed integers. D.i32 = (S0.i32 >= S1.i32 ? S0.i32 : S1.i32)."
                },
                {
                    "opcode": "19",
                    "name": "V_MIN_U32",
                    "short": "Compute the minimum of two unsigned integers",
                    "description": "Compute the minimum of two unsigned integers. D.u32 = (S0.u32 < S1.u32 ? S0.u32 : S1.u32)."
                },
                {
                    "opcode": "20",
                    "name": "V_MAX_U32",
                    "short": "Compute the maximum of two unsigned integers",
                    "description": "Compute the maximum of two unsigned integers. D.u32 = (S0.u32 >= S1.u32 ? S0.u32 : S1.u32)."
                },
                {
                    "opcode": "22",
                    "name": "V_LSHRREV_B32",
                    "short": "Logical shift right with shift count in the first operand",
                    "description": "Logical shift right with shift count in the first operand. D.u32 = S1.u32 >> S0[4:0]."
                },
                {
                    "opcode": "24",
                    "name": "V_ASHRREV_I32",
                    "short": "Arithmetic shift right (preserve sign bit) with shift count in the first operand",
                    "description": "Arithmetic shift right (preserve sign bit) with shift count in the first operand. D.i32 = S1.i32 >> S0[4:0]."
                },
                {
                    "opcode": "26",
                    "name": "V_LSHLREV_B32",
                    "short": "Logical shift left with shift count in the first operand",
                    "description": "Logical shift left with shift count in the first operand. D.u32 = S1.u32 << S0[4:0]."
                },
                {
                    "opcode": "27",
                    "name": "V_AND_B32",
                    "short": "Bitwise AND",
                    "description": "Bitwise AND.  Input and output modifiers not supported. D.u32 = S0.u32 & S1.u32."
                },
                {
                    "opcode": "28",
                    "name": "V_OR_B32",
                    "short": "Bitwise OR",
                    "description": "Bitwise OR.  Input and output modifiers not supported. D.u32 = S0.u32 | S1.u32."
                },
                {
                    "opcode": "29",
                    "name": "V_XOR_B32",
                    "short": "Bitwise XOR",
                    "description": "Bitwise XOR.  Input and output modifiers not supported. D.u32 = S0.u32 ^ S1.u32."
                },
                {
                    "opcode": "30",
                    "name": "V_XNOR_B32",
                    "short": "Bitwise XNOR",
                    "description": "Bitwise XNOR. Input and output modifiers not supported. D.u32 = ~(S0.u32 ^ S1.u32)."
                },
                {
                    "opcode": "37",
                    "name": "V_ADD_NC_U32",
                    "short": "Add two unsigned integers",
                    "description": "Add two unsigned integers. No carry-in or carry-out. D.u32 = S0.u32 + S1.u32."
                },
                {
                    "opcode": "38",
                    "name": "V_SUB_NC_U32",
                    "short": "Subtract the second unsigned integer from the first unsigned integer",
                    "description": "Subtract the second unsigned integer from the first unsigned integer.  No carry-in or carry-out. D.u32 = S0.u32 - S1.u32."
                },
                {
                    "opcode": "39",
                    "name": "V_SUBREV_NC_U32",
                    "short": "Subtract the first unsigned integer from the second unsigned integer",
                    "description": "Subtract the first unsigned integer from the second unsigned integer.  No carry-in or carry-out. D.u32 = S1.u32 - S0.u32."
                },
                {
                    "opcode": "40",
                    "name": "V_ADD_CO_CI_U32",
                    "short": "Add two unsigned integers and a carry-in from VCC",
                    "description": "Add two unsigned integers and a carry-in from VCC.  Store the result and also save the carry-out to VCC.  In VOP3 the VCC destination may be an arbitrary SGPR-pair, and the VCC source comes from the SGPR-pair at S2.u. D.u32 = S0.u32 + S1.u32 + VCC; VCC = S0.u32 + S1.u32 + VCC >= 0x100000000ULL ? 1 : 0."
                },
                {
                    "opcode": "41",
                    "name": "V_SUB_CO_CI_U32",
                    "short": "Subtract the second unsigned integer from the first unsigned integer and then subtract a carry-in from VCC",
                    "description": "Subtract the second unsigned integer from the first unsigned integer and then subtract a carry-in from VCC.  Store the result and also save the carry-out to VCC.  In VOP3 the VCC destination may be an arbitrary SGPR-pair, and the VCC source comes from the SGPR-pair at S2.u. D.u32 = S0.u32 - S1.u32 - VCC; VCC = S1.u32 + VCC > S0.u32 ? 1 : 0."
                },
                {
                    "opcode": "42",
                    "name": "V_SUBREV_CO_CI_U3",
                    "short": "Subtract the first unsigned integer from the second unsigned 2 integer and then subtract a carry-in from VCC",
                    "description": "Subtract the first unsigned integer from the second unsigned 2 integer and then subtract a carry-in from VCC.  Store the result and also save the carry-out to VCC.  In VOP3 the VCC destination may be an arbitrary SGPR-pair, and the VCC source comes from the SGPR-pair at S2.u. D.u32 = S1.u32 - S0.u32 - VCC; VCC = S1.u32 + VCC > S0.u ? 1 : 0."
                },
                {
                    "opcode": "43",
                    "name": "V_FMAC_F32",
                    "short": "Fused multiply-add of single-precision floats, accumulate with destination",
                    "description": "Fused multiply-add of single-precision floats, accumulate with destination. D.f32 = S0.f32 * S1.f32 + D.f32. // Fused operation"
                },
                {
                    "opcode": "44",
                    "name": "V_FMAMK_F32",
                    "short": "Multiply a single-precision float with a literal constant and add a second single-precision float using fused multiply-add",
                    "description": "Multiply a single-precision float with a literal constant and add a second single-precision float using fused multiply-add. This opcode cannot use the VOP3 encoding and cannot use input/output modifiers. D.f32 = S0.f32 * K.f32 + S1.f32. // K is a 32-bit literal constant."
                },
                {
                    "opcode": "45",
                    "name": "V_FMAAK_F32",
                    "short": "Multiply two single-precision floats and add a literal constant using fused multiply-add",
                    "description": "Multiply two single-precision floats and add a literal constant using fused multiply-add.  This opcode cannot use the VOP3 encoding and cannot use input/output modifiers. D.f32 = S0.f32 * S1.f32 + K.f32. // K is a 32-bit literal constant."
                },
                {
                    "opcode": "47",
                    "name": "V_CVT_PKRTZ_F16_F32",
                    "short": " Convert two single-precision floats into a packed FP16 result and round to zero (ignore the current rounding mode)",
                    "description": " Convert two single-precision floats into a packed FP16 result and round to zero (ignore the current rounding mode). This opcode is intended for use with 16-bit compressed exports. See V_CVT_F16_F32 for a version that respects the current rounding mode. D.f16_lo = f32_to_f16(S0.f32); D.f16_hi = f32_to_f16(S1.f32). // Round-toward-zero regardless of current round mode setting in hardware."
                },
                {
                    "opcode": "50",
                    "name": "V_ADD_F16",
                    "short": "Add two FP16 values",
                    "description": "Add two FP16 values.  0.5ULP precision.  Supports denormals, round mode, exception flags and saturation. D.f16_lo = S0.f16_lo + S1.f16_lo."
                },
                {
                    "opcode": "51",
                    "name": "V_SUB_F16",
                    "short": "Subtract the second FP16 value from the first",
                    "description": "Subtract the second FP16 value from the first.  0.5ULP precision, Supports denormals, round mode, exception flags and saturation. D.f16_lo = S0.f16_lo - S1.f16_lo."
                },
                {
                    "opcode": "52",
                    "name": "V_SUBREV_F16",
                    "short": "Subtract the first FP16 value from the second",
                    "description": "Subtract the first FP16 value from the second.  0.5ULP precision.  Supports denormals, round mode, exception flags and saturation. D.f16_lo = S1.f16_lo - S0.f16_lo."
                },
                {
                    "opcode": "53",
                    "name": "V_MUL_F16",
                    "short": "Multiply two FP16 values",
                    "description": "Multiply two FP16 values.  0.5ULP precision.  Supports denormals, round mode, exception flags and saturation. D.f16_lo = S0.f16_lo * S1.f16_lo."
                },
                {
                    "opcode": "54",
                    "name": "V_FMAC_F16",
                    "short": "Fused multiply-add of FP16 values, accumulate with destination",
                    "description": "Fused multiply-add of FP16 values, accumulate with destination. 0.5ULP precision.  Supports denormals, round mode, exception flags and saturation. D.f16_lo = S0.f16_lo * S1.f16_lo + D.f16_lo."
                },
                {
                    "opcode": "55",
                    "name": "V_FMAMK_F16",
                    "short": "Multiply a FP16 value with a literal constant and add a second FP16 value using fused multiply-add",
                    "description": "Multiply a FP16 value with a literal constant and add a second FP16 value using fused multiply-add.  This opcode cannot use the VOP3 encoding and cannot use input/output modifiers.  Supports round mode, exception flags, saturation. D.f16_lo = S0.f16_lo * K.f16_lo + S1.f16_lo. // K is a 32-bit literal constant stored in the following literal DWORD."
                },
                {
                    "opcode": "56",
                    "name": "V_FMAAK_F16",
                    "short": "Multiply two FP16 values and add a literal constant using fused multiply-add",
                    "description": "Multiply two FP16 values and add a literal constant using fused multiply-add.  This opcode cannot use the VOP3 encoding and cannot use input/output modifiers.  Supports round mode, exception flags, saturation. D.f16_lo = S0.f16_lo * S1.f16_lo + K.f16_lo. // K is a 32-bit literal constant stored in the following literal DWORD."
                },
                {
                    "opcode": "57",
                    "name": "V_MAX_F16",
                    "short": "Maximum of two FP16 values",
                    "description": "Maximum of two FP16 values.  IEEE compliant.  Supports denormals, round mode, exception flags, saturation. D.f16 = max(S0.f16,S1.f16); if (IEEE_MODE && S0.f16 == sNaN) D.f16 = Quiet(S0.f16); else if (IEEE_MODE && S1.f16 == sNaN) D.f16 = Quiet(S1.f16); else if (S0.f16 == NaN) D.f16 = S1.f16; else if (S1.f16 == NaN) D.f16 = S0.f16; else if (S0.f16 == +0.0 && S1.f16 == -0.0) D.f16 = S0.f16; else if (S0.f16 == -0.0 && S1.f16 == +0.0) D.f16 = S1.f16; else if (IEEE_MODE) D.f16 = (S0.f16 >= S1.f16 ? S0.f16 : S1.f16); else D.f16 = (S0.f16 > S1.f16 ? S0.f16 : S1.f16); endif."
                },
                {
                    "opcode": "58",
                    "name": "V_MIN_F16",
                    "short": "Minimum of two FP16 values",
                    "description": "Minimum of two FP16 values.  IEEE compliant.  Supports denormals, round mode, exception flags, saturation. D.f16 = min(S0.f16,S1.f16); if (IEEE_MODE && S0.f16 == sNaN) D.f16 = Quiet(S0.f16); else if (IEEE_MODE && S1.f16 == sNaN) D.f16 = Quiet(S1.f16); else if (S0.f16 == NaN) D.f16 = S1.f16; else if (S1.f16 == NaN) D.f16 = S0.f16; else if (S0.f16 == +0.0 && S1.f16 == -0.0) D.f16 = S1.f16; else if (S0.f16 == -0.0 && S1.f16 == +0.0) D.f16 = S0.f16; else // Note: there's no IEEE special case here like there is for V_MAX_F16. D.f16 = (S0.f16 < S1.f16 ? S0.f16 : S1.f16); endif."
                },
                {
                    "opcode": "59",
                    "name": "V_LDEXP_F16",
                    "short": "Multiply an FP16 value by an integral power of 2, compare with the ldexp() function in C",
                    "description": "Multiply an FP16 value by an integral power of 2, compare with the ldexp() function in C.  Note that the S1 has a format of f16 since floating point literal constants are interpreted as 16 bit value for this opcode. D.f16 = S0.f16 * (2 ** S1.i16)."
                },
                {
                    "opcode": "60",
                    "name": "V_PK_FMAC_F16",
                    "short": "Multiply packed FP16 values and accumulate with destination",
                    "description": "Multiply packed FP16 values and accumulate with destination. VOP2 version of V_PK_FMA_F16 with third source VGPR address is the destination. D.f16_lo = S0.f16_lo * S1.f16_lo + D.f16_lo; D.f16_hi = S0.f16_hi * S1.f16_hi + D.f16_hi."
                }
            ]
        },
        {
            "key": "vop1",
            "name": "VOP1 Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "V_NOP",
                    "short": "Do nothing, with style!\n",
                    "description": "Do nothing, with style!"
                },
                {
                    "opcode": "1",
                    "name": "V_MOV_B32",
                    "short": "Move data to a VGPR",
                    "description": "Move data to a VGPR.  Floating-point modifiers are valid for this instruction if S0.u is a 32-bit floating point value.  This instruction is suitable for negating or taking the absolute value of a floating-point value. D.u = S0.u. Examples: v_mov_b32 v0, v1// Move v1 to v0 v_mov_b32 v0, -v1// Set v1 to the negation of v0 v_mov_b32 v0, abs(v1)// Set v1 to the absolute value of v0"
                },
                {
                    "opcode": "2",
                    "name": "V_READFIRSTLANE_B32",
                    "short": "Copy one VGPR value to one SGPR",
                    "description": "Copy one VGPR value to one SGPR.  D = SGPR destination, S0 = source data (VGPR# or M0 for lds direct access), Lane# = FindFirst1fromLSB(exec) (Lane# = 0 if exec is zero).  Ignores exec mask for the access.  Input and output modifiers not supported; this is an untyped operation."
                },
                {
                    "opcode": "3",
                    "name": "V_CVT_I32_F64",
                    "short": "Convert from a double-precision float to a signed integer",
                    "description": "Convert from a double-precision float to a signed integer. 0.5ULP accuracy, out-of-range floating point values (including infinity) saturate.  NaN is converted to 0.  Generation of the INEXACT exception is controlled by the CLAMP bit.  INEXACT exceptions are enabled for this conversion iff CLAMP == 1. D.i = (int)S0.d."
                },
                {
                    "opcode": "4",
                    "name": "V_CVT_F64_I32",
                    "short": "Convert from a signed integer to a double-precision float, 0ULP accuracy",
                    "description": "Convert from a signed integer to a double-precision float, 0ULP accuracy. D.d = (double)S0.i."
                },
                {
                    "opcode": "5",
                    "name": "V_CVT_F32_I32",
                    "short": "Convert from a signed integer to a single-precision float, 0",
                    "description": "Convert from a signed integer to a single-precision float, 0.5ULP accuracy. D.f = (float)S0.i."
                },
                {
                    "opcode": "6",
                    "name": "V_CVT_F32_U32",
                    "short": "Convert from an unsigned integer to a single-precision float, 0",
                    "description": "Convert from an unsigned integer to a single-precision float, 0.5ULP accuracy. D.f = (float)S0.u."
                },
                {
                    "opcode": "7",
                    "name": "V_CVT_U32_F32",
                    "short": "Convert from a single-precision float to an unsigned integer",
                    "description": "Convert from a single-precision float to an unsigned integer. 1ULP accuracy, out-of-range floating point values (including infinity) saturate.  NaN is converted to 0.  Generation of the INEXACT exception is controlled by the CLAMP bit.  INEXACT exceptions are enabled for this conversion iff CLAMP == 1. D.u = (unsigned)S0.f."
                },
                {
                    "opcode": "8",
                    "name": "V_CVT_I32_F32",
                    "short": "Convert from a single-precision float to a signed integer",
                    "description": "Convert from a single-precision float to a signed integer.  1ULP accuracy, out-of-range floating point values (including infinity) saturate.  NaN is converted to 0.  Generation of the INEXACT exception is controlled by the CLAMP bit.  INEXACT exceptions are enabled for this conversion iff CLAMP == 1. D.i = (int)S0.f."
                },
                {
                    "opcode": "10",
                    "name": "V_CVT_F16_F32",
                    "short": "Convert from a single-precision float to an FP16 float",
                    "description": "Convert from a single-precision float to an FP16 float.  0.5ULP accuracy, supports input modifiers and creates FP16 denormals when appropriate. D.f16 = flt32_to_flt16(S0.f)."
                },
                {
                    "opcode": "11",
                    "name": "V_CVT_F32_F16",
                    "short": "Convert from an FP16 float to a single-precision float",
                    "description": "Convert from an FP16 float to a single-precision float.  0ULP accuracy, FP16 denormal inputs are accepted. D.f = flt16_to_flt32(S0.f16)."
                },
                {
                    "opcode": "12",
                    "name": "V_CVT_RPI_I32_F32",
                    "short": "Convert from a single-precision float to a signed integer, round to nearest integer",
                    "description": "Convert from a single-precision float to a signed integer, round to nearest integer.0.5ULP accuracy, denormals are supported. D.i = (int)floor(S0.f + 0.5)."
                },
                {
                    "opcode": "13",
                    "name": "V_CVT_FLR_I32_F32",
                    "short": "Convert from a single-precision float to a signed integer, round down",
                    "description": "Convert from a single-precision float to a signed integer, round down.  1ULP accuracy, denormals are supported. D.i = (int)floor(S0.f)."
                },
                {
                    "opcode": "14",
                    "name": "V_CVT_OFF_F32_I4",
                    "short": "4-bit signed int to 32-bit float",
                    "description": "4-bit signed int to 32-bit float.  Used for interpolation in shader. S0___Result__ 1000 -0.5000f 1001 -0.4375f 1010 -0.3750f 1011 -0.3125f 1100 -0.2500f 1101 -0.1875f 1110 -0.1250f 1111 -0.0625f 0000 +0.0000f 0001 +0.0625f 0010 +0.1250f 0011 +0.1875f 0100 +0.2500f 0101 +0.3125f 0110 +0.3750f 0111 +0.4375f"
                },
                {
                    "opcode": "15",
                    "name": "V_CVT_F32_F64",
                    "short": "Convert from a double-precision float to a single-precision float",
                    "description": "Convert from a double-precision float to a single-precision float.  0.5ULP accuracy, denormals are supported. D.f = (float)S0.d."
                },
                {
                    "opcode": "16",
                    "name": "V_CVT_F64_F32",
                    "short": "Convert from a single-precision float to a double-precision float",
                    "description": "Convert from a single-precision float to a double-precision float. 0ULP accuracy, denormals are supported. D.d = (double)S0.f."
                },
                {
                    "opcode": "17",
                    "name": "V_CVT_F32_UBYTE0",
                    "short": "Convert an unsigned byte (byte 0) to a single-precision float",
                    "description": "Convert an unsigned byte (byte 0) to a single-precision float. D.f = (float)(S0.u[7:0])."
                },
                {
                    "opcode": "18",
                    "name": "V_CVT_F32_UBYTE1",
                    "short": "Convert an unsigned byte (byte 1) to a single-precision float",
                    "description": "Convert an unsigned byte (byte 1) to a single-precision float. D.f = (float)(S0.u[15:8])."
                },
                {
                    "opcode": "19",
                    "name": "V_CVT_F32_UBYTE2",
                    "short": "Convert an unsigned byte (byte 2) to a single-precision float",
                    "description": "Convert an unsigned byte (byte 2) to a single-precision float. D.f = (float)(S0.u[23:16])."
                },
                {
                    "opcode": "20",
                    "name": "V_CVT_F32_UBYTE3",
                    "short": "Convert an unsigned byte (byte 3) to a single-precision float",
                    "description": "Convert an unsigned byte (byte 3) to a single-precision float. D.f = (float)(S0.u[31:24])."
                },
                {
                    "opcode": "21",
                    "name": "V_CVT_U32_F64",
                    "short": "Convert from a double-precision float to an unsigned integer",
                    "description": "Convert from a double-precision float to an unsigned integer. 0.5ULP accuracy, out-of-range floating point values (including infinity) saturate.  NaN is converted to 0.  Generation of the INEXACT exception is controlled by the CLAMP bit.  INEXACT exceptions are enabled for this conversion iff CLAMP == 1. D.u = (unsigned)S0.d."
                },
                {
                    "opcode": "22",
                    "name": "V_CVT_F64_U32",
                    "short": "Convert from an unsigned integer to a double-precision float",
                    "description": "Convert from an unsigned integer to a double-precision float. 0ULP accuracy. D.d = (double)S0.u."
                },
                {
                    "opcode": "23",
                    "name": "V_TRUNC_F64",
                    "short": "Return integer part of S0",
                    "description": "Return integer part of S0.d, round-to-zero semantics. D.d = trunc(S0.d)."
                },
                {
                    "opcode": "24",
                    "name": "V_CEIL_F64",
                    "short": "Round up to next whole integer",
                    "description": "Round up to next whole integer. D.d = trunc(S0.d); if(S0.d > 0.0 && S0.d != D.d) then D.d += 1.0; endif."
                },
                {
                    "opcode": "25",
                    "name": "V_RNDNE_F64",
                    "short": "Round-to-nearest-even semantics",
                    "description": "Round-to-nearest-even semantics. D.d = floor(S0.d + 0.5); if(floor(S0.d) is even && fract(S0.d) == 0.5) then D.d -= 1.0; endif."
                },
                {
                    "opcode": "26",
                    "name": "V_FLOOR_F64",
                    "short": "Round down to previous whole integer",
                    "description": "Round down to previous whole integer. D.d = trunc(S0.d); if(S0.d < 0.0 && S0.d != D.d) then D.d += -1.0; endif."
                },
                {
                    "opcode": "27",
                    "name": "V_PIPEFLUSH",
                    "short": "Flush the VALU destination cache",
                    "description": "Flush the VALU destination cache."
                },
                {
                    "opcode": "32",
                    "name": "V_FRACT_F32",
                    "short": "Return fractional portion of a number",
                    "description": "Return fractional portion of a number.  0.5ULP accuracy, denormals are accepted. D.f = S0.f + -floor(S0.f). NOTE: This complies with the DX specification of fract where the function behaves like an extension of integer modulus; be aware this may differ from how fract() is defined in other domains. For example: fract(-1.2) = 0.8 in DX."
                },
                {
                    "opcode": "33",
                    "name": "V_TRUNC_F32",
                    "short": "Return integer part of S0",
                    "description": "Return integer part of S0.f, round-to-zero semantics. D.f = trunc(S0.f)."
                },
                {
                    "opcode": "34",
                    "name": "V_CEIL_F32",
                    "short": "Round up to next whole integer",
                    "description": "Round up to next whole integer. D.f = trunc(S0.f); if(S0.f > 0.0 && S0.f != D.f) then D.f += 1.0; endif."
                },
                {
                    "opcode": "35",
                    "name": "V_RNDNE_F32",
                    "short": "Round-to-nearest-even semantics",
                    "description": "Round-to-nearest-even semantics. D.f = floor(S0.f + 0.5); if(floor(S0.f) is even && fract(S0.f) == 0.5) then D.f -= 1.0; endif."
                },
                {
                    "opcode": "36",
                    "name": "V_FLOOR_F32",
                    "short": "Round down to previous whole integer",
                    "description": "Round down to previous whole integer. D.f = trunc(S0.f); if(S0.f < 0.0 && S0.f != D.f) then D.f += -1.0; endif."
                },
                {
                    "opcode": "37",
                    "name": "V_EXP_F32",
                    "short": "Base 2 exponentiation",
                    "description": "Base 2 exponentiation.  1ULP accuracy, denormals are flushed. D.f = pow(2.0, S0.f). Functional examples: V_EXP_F32(0xff800000) => 0x00000000    // exp(-INF) = 0 V_EXP_F32(0x80000000) => 0x3f800000    // exp(-0.0) = 1 V_EXP_F32(0x7f800000) => 0x7f800000    // exp(+INF) = +INF"
                },
                {
                    "opcode": "39",
                    "name": "V_LOG_F32",
                    "short": "Base 2 logarithm",
                    "description": "Base 2 logarithm.  1ULP accuracy, denormals are flushed. D.f = log2(S0.f). Functional examples: V_LOG_F32(0xff800000) => 0xffc00000    // log(-INF) = NAN V_LOG_F32(0xbf800000) => 0xffc00000    // log(-1.0) = NAN V_LOG_F32(0x80000000) => 0xff800000    // log(-0.0) = -INF V_LOG_F32(0x00000000) => 0xff800000    // log(+0.0) = -INF V_LOG_F32(0x3f800000) => 0x00000000    // log(+1.0) = 0 V_LOG_F32(0x7f800000) => 0x7f800000    // log(+INF) = +INF"
                },
                {
                    "opcode": "42",
                    "name": "V_RCP_F32",
                    "short": "Compute reciprocal with IEEE rules",
                    "description": "Compute reciprocal with IEEE rules.  1ULP accuracy.  Accuracy converges to < 0.5ULP when using the Newton-Raphson method and 2 FMA operations.  Denormals are flushed. D.f = 1.0 / S0.f. Functional examples: V_RCP_F32(0xff800000) => 0x80000000    // rcp(-INF) = -0 V_RCP_F32(0xc0000000) => 0xbf000000    // rcp(-2.0) = -0.5 V_RCP_F32(0x80000000) => 0xff800000    // rcp(-0.0) = -INF V_RCP_F32(0x00000000) => 0x7f800000    // rcp(+0.0) = +INF V_RCP_F32(0x7f800000) => 0x00000000    // rcp(+INF) = +0"
                },
                {
                    "opcode": "43",
                    "name": "V_RCP_IFLAG_F32",
                    "short": "Compute reciprocal as part of integer divide",
                    "description": "Compute reciprocal as part of integer divide.  Can raise integer DIV_BY_ZERO exception but cannot raise floating-point exceptions.  To be used in an integer reciprocal macro by the compiler with one of the following sequences: D.f = 1.0 / S0.f. Unsigned usage: CVT_F32_U32 RCP_IFLAG_F32 MUL_F32 (2**32 - 1) CVT_U32_F32 Signed usage: CVT_F32_I32 RCP_IFLAG_F32 MUL_F32 (2**31 - 1) CVT_I32_F32"
                },
                {
                    "opcode": "46",
                    "name": "V_RSQ_F32",
                    "short": "Reciprocal square root with IEEE rules",
                    "description": "Reciprocal square root with IEEE rules.  1ULP accuracy, denormals are flushed. D.f = 1.0 / sqrt(S0.f). Functional examples: V_RSQ_F32(0xff800000) => 0xffc00000    // rsq(-INF) = NAN V_RSQ_F32(0x80000000) => 0xff800000    // rsq(-0.0) = -INF V_RSQ_F32(0x00000000) => 0x7f800000    // rsq(+0.0) = +INF V_RSQ_F32(0x40800000) => 0x3f000000    // rsq(+4.0) = +0.5 V_RSQ_F32(0x7f800000) => 0x00000000    // rsq(+INF) = +0"
                },
                {
                    "opcode": "47",
                    "name": "V_RCP_F64",
                    "short": "Reciprocal with IEEE rules",
                    "description": "Reciprocal with IEEE rules.  Precision is (2**29) ULP, and supports denormals. D.d = 1.0 / S0.d."
                },
                {
                    "opcode": "49",
                    "name": "V_RSQ_F64",
                    "short": "Reciprocal square root with IEEE rules",
                    "description": "Reciprocal square root with IEEE rules.  Precision is (2**29) ULP, and supports denormals. D.f16 = 1.0 / sqrt(S0.f16)."
                },
                {
                    "opcode": "51",
                    "name": "V_SQRT_F32",
                    "short": "Square root",
                    "description": "Square root.  1ULP accuracy, denormals are flushed. D.f = sqrt(S0.f). Functional examples: V_SQRT_F32(0xff800000) => 0xffc00000    // sqrt(-INF) = NAN V_SQRT_F32(0x80000000) => 0x80000000    // sqrt(-0.0) = -0 V_SQRT_F32(0x00000000) => 0x00000000    // sqrt(+0.0) = +0 V_SQRT_F32(0x40800000) => 0x40000000    // sqrt(+4.0) = +2.0 V_SQRT_F32(0x7f800000) => 0x7f800000    // sqrt(+INF) = +INF"
                },
                {
                    "opcode": "52",
                    "name": "V_SQRT_F64",
                    "short": "Square root",
                    "description": "Square root.  Precision is (2**29) ULP, and supports denormals. D.d = sqrt(S0.d)."
                },
                {
                    "opcode": "53",
                    "name": "V_SIN_F32",
                    "short": "Trigonometric sine",
                    "description": "Trigonometric sine.  Denormals are supported. D.f = sin(S0.f * 2 * PI). Functional examples: V_SIN_F32(0xff800000) => 0xffc00000    // sin(-INF) = NAN V_SIN_F32(0xff7fffff) => 0x00000000    // -MaxFloat, finite V_SIN_F32(0x80000000) => 0x80000000    // sin(-0.0) = -0 V_SIN_F32(0x3e800000) => 0x3f800000    // sin(0.25) = 1 V_SIN_F32(0x7f800000) => 0xffc00000    // sin(+INF) = NAN"
                },
                {
                    "opcode": "54",
                    "name": "V_COS_F32",
                    "short": "Trigonometric cosine",
                    "description": "Trigonometric cosine.  Denormals are supported. D.f = cos(S0.f * 2 * PI). Functional examples: V_COS_F32(0xff800000) => 0xffc00000    // cos(-INF) = NAN V_COS_F32(0xff7fffff) => 0x3f800000    // -MaxFloat, finite V_COS_F32(0x80000000) => 0x3f800000    // cos(-0.0) = 1 V_COS_F32(0x3e800000) => 0x00000000    // cos(0.25) = 0 V_COS_F32(0x7f800000) => 0xffc00000    // cos(+INF) = NAN"
                },
                {
                    "opcode": "55",
                    "name": "V_NOT_B32",
                    "short": "Bitwise negation",
                    "description": "Bitwise negation.  Input and output modifiers not supported. D.u = ~S0.u."
                },
                {
                    "opcode": "56",
                    "name": "V_BFREV_B32",
                    "short": "Bitfield reverse",
                    "description": "Bitfield reverse.  Input and output modifiers not supported. D.u[31:0] = S0.u[0:31]."
                },
                {
                    "opcode": "57",
                    "name": "V_FFBH_U32",
                    "short": "Counts how many zeros before the first one starting from the MSB",
                    "description": "Counts how many zeros before the first one starting from the MSB. Returns -1 if there are no ones. D.i = -1; // Set if no ones are found for i in 0 ... 31 do // Note: search is from the MSB if S0.u[31 - i] == 1 then D.i = i; break for; endif; endfor. Functional examples: V_FFBH_U32(0x00000000) => 0xffffffff V_FFBH_U32(0x800000ff) => 0 V_FFBH_U32(0x100000ff) => 3 V_FFBH_U32(0x0000ffff) => 16 V_FFBH_U32(0x00000001) => 31"
                },
                {
                    "opcode": "58",
                    "name": "V_FFBL_B32",
                    "short": "Returns the bit position of the first one from the LSB, or -1 if there are no ones",
                    "description": "Returns the bit position of the first one from the LSB, or -1 if there are no ones. D.i = -1; // Set if no ones are found for i in 0 ... 31 do // Search from LSB if S0.u[i] == 1 then D.i = i; break for; endif; endfor. Functional examples: V_FFBL_B32(0x00000000) => 0xffffffff V_FFBL_B32(0xff000001) => 0 V_FFBL_B32(0xff000008) => 3 V_FFBL_B32(0xffff0000) => 16 V_FFBL_B32(0x80000000) => 31"
                },
                {
                    "opcode": "59",
                    "name": "V_FFBH_I32",
                    "short": "Counts how many bits in a row (from MSB to LSB) are the same as the sign bit",
                    "description": "Counts how many bits in a row (from MSB to LSB) are the same as the sign bit.  Returns -1 if all bits are the same. D.i = -1; // Set if all bits are the same for i in 1 ... 31 do // Note: search is from the MSB if S0.i[31 - i] != S0.i[31] then D.i = i; break for; endif; endfor. Functional examples: V_FFBH_I32(0x00000000) => 0xffffffff V_FFBH_I32(0x40000000) => 1 V_FFBH_I32(0x80000000) => 1 V_FFBH_I32(0x0fffffff) => 4 V_FFBH_I32(0xffff0000) => 16 V_FFBH_I32(0xfffffffe) => 31 V_FFBH_I32(0xffffffff) => 0xffffffff"
                },
                {
                    "opcode": "60",
                    "name": "V_FREXP_EXP_I32_F6",
                    "short": "Returns exponent of single precision float input, such that S0",
                    "description": "Returns exponent of single precision float input, such that S0.d 4 = significand * (2 ** exponent).  See also V_FREXP_MANT_F64, which returns the significand.  See the C library function frexp() for more information. if(S0.f64 == +-INF || S0.f64 == NAN) D.i32 = 0; else D.i32 = S0.f64.exp - 1023 + 1; endif."
                },
                {
                    "opcode": "61",
                    "name": "V_FREXP_MANT_F64",
                    "short": "Returns binary significand of double precision float input, such that S0",
                    "description": "Returns binary significand of double precision float input, such that S0.d = significand * (2 ** exponent).  Result range is in (-1.0,-0.5][0.5,1.0) in normal cases.  See also V_FREXP_EXP_I32_F64, which returns integer exponent.  See the C library function frexp() for more information. if(S0.d == +-INF || S0.d == NAN) then D.d = S0.d; else D.d = Mantissa(S0.d); endif."
                },
                {
                    "opcode": "62",
                    "name": "V_FRACT_F64",
                    "short": "Return fractional portion of a number",
                    "description": "Return fractional portion of a number.  0.5ULP accuracy, denormals are accepted. D.d = S0.d + -floor(S0.d). NOTE: This complies with the DX specification of fract where the function behaves like an extension of integer modulus; be aware this may differ from how fract() is defined in other domains. For example: fract(-1.2) = 0.8 in DX."
                },
                {
                    "opcode": "63",
                    "name": "V_FREXP_EXP_I32_F3",
                    "short": "Returns exponent of single precision float input, such that S0",
                    "description": "Returns exponent of single precision float input, such that S0.f 2 = significand * (2 ** exponent). See also V_FREXP_MANT_F32, which returns the significand.  See the C library function frexp() for more information. if(S0.f == +-INF || S0.f == NAN) then D.i = 0; else D.i = TwosComplement(Exponent(S0.f) - 127 + 1); endif."
                },
                {
                    "opcode": "64",
                    "name": "V_FREXP_MANT_F32",
                    "short": "Returns binary significand of single precision float input, such that S0",
                    "description": "Returns binary significand of single precision float input, such that S0.f = significand * (2 ** exponent).  Result range is in (-1.0,-0.5][0.5,1.0) in normal cases.  See also V_FREXP_EXP_I32_F32, which returns integer exponent.  See the C library function frexp() for more information. if(S0.f == +-INF || S0.f == NAN) then D.f = S0.f; else D.f = Mantissa(S0.f); endif."
                },
                {
                    "opcode": "65",
                    "name": "V_CLREXCP",
                    "short": "Clear this wave's exception state in the SIMD (SP)",
                    "description": "Clear this wave's exception state in the SIMD (SP)."
                },
                {
                    "opcode": "66",
                    "name": "V_MOVRELD_B32",
                    "short": "Move to a relative destination address",
                    "description": "Move to a relative destination address. addr = VGPR address appearing in instruction DST field; addr += M0.u[31:0]; VGPR[addr].u = S0.u. Example: The following instruction sequence will perform a move v15 <== v7: s_mov_b32 m0, 10 v_movreld_b32 v5, v7"
                },
                {
                    "opcode": "67",
                    "name": "V_MOVRELS_B32",
                    "short": "Move from a relative source address",
                    "description": "Move from a relative source address. addr = VGPR address appearing in instruction SRC0 field; addr += M0.u[31:0]; D.u = VGPR[addr].u. Example: The following instruction sequence will perform a move v5 <== v17: s_mov_b32 m0, 10 v_movrels_b32 v5, v7"
                },
                {
                    "opcode": "68",
                    "name": "V_MOVRELSD_B32",
                    "short": "Move from a relative source address to a relative destination address",
                    "description": "Move from a relative source address to a relative destination address. addr_src = VGPR address appearing in instruction SRC0 field; addr_src += M0.u[31:0]; addr_dst = VGPR address appearing in instruction DST field; addr_dst += M0.u[31:0]; VGPR[addr_dst].u = VGPR[addr_src].u. Example: The following instruction sequence will perform a move v15 <== v17: s_mov_b32 m0, 10 v_movrelsd_b32 v5, v7"
                },
                {
                    "opcode": "72",
                    "name": "V_MOVRELSD_2_B32",
                    "short": "Move from a relative source address to a relative destination address, with different relative offsets",
                    "description": "Move from a relative source address to a relative destination address, with different relative offsets. addr_src = VGPR address appearing in instruction SRC0 field; addr_src += M0.u[9:0]; addr_dst = VGPR address appearing in instruction DST field; addr_dst += M0.u[25:16]; VGPR[addr_dst].u = VGPR[addr_src].u. Example: The following instruction sequence will perform a move v25 <== v17: s_mov_b32 m0, ((20 << 16) | 10) v_movrelsd_2_b32 v5, v7"
                },
                {
                    "opcode": "80",
                    "name": "V_CVT_F16_U16",
                    "short": "Convert from an unsigned short to an FP16 float",
                    "description": "Convert from an unsigned short to an FP16 float.  0.5ULP accuracy, supports denormals, rounding, exception flags and saturation. D.f16 = uint16_to_flt16(S.u16)."
                },
                {
                    "opcode": "81",
                    "name": "V_CVT_F16_I16",
                    "short": "Convert from a signed short to an FP16 float",
                    "description": "Convert from a signed short to an FP16 float.  0.5ULP accuracy, supports denormals, rounding, exception flags and saturation. D.f16 = int16_to_flt16(S.i16)."
                },
                {
                    "opcode": "82",
                    "name": "V_CVT_U16_F16",
                    "short": "Convert from an FP16 float to an unsigned short",
                    "description": "Convert from an FP16 float to an unsigned short.  1ULP accuracy, supports rounding, exception flags and saturation.  FP16 denormals are accepted.  Conversion is done with truncation. Generation of the INEXACT exception is controlled by the CLAMP bit.  INEXACT exceptions are enabled for this conversion iff CLAMP == 1. D.u16 = flt16_to_uint16(S.f16)."
                },
                {
                    "opcode": "83",
                    "name": "V_CVT_I16_F16",
                    "short": "Convert from an FP16 float to a signed short",
                    "description": "Convert from an FP16 float to a signed short.  1ULP accuracy, supports rounding, exception flags and saturation.  FP16 denormals are accepted.  Conversion is done with truncation. Generation of the INEXACT exception is controlled by the CLAMP bit.  INEXACT exceptions are enabled for this conversion iff CLAMP == 1. D.i16 = flt16_to_int16(S.f16)."
                },
                {
                    "opcode": "84",
                    "name": "V_RCP_F16",
                    "short": "Reciprocal with IEEE rules",
                    "description": "Reciprocal with IEEE rules. 0.51ULP accuracy. D.f16 = 1.0 / S0.f16. Functional examples: V_RCP_F16(0xfc00) => 0x8000    // rcp(-INF) = -0 V_RCP_F16(0xc000) => 0xb800    // rcp(-2.0) = -0.5 V_RCP_F16(0x8000) => 0xfc00    // rcp(-0.0) = -INF V_RCP_F16(0x0000) => 0x7c00    // rcp(+0.0) = +INF V_RCP_F16(0x7c00) => 0x0000    // rcp(+INF) = +0"
                },
                {
                    "opcode": "85",
                    "name": "V_SQRT_F16",
                    "short": "Square root",
                    "description": "Square root. 0.51ULP accuracy, denormals are supported. D.f16 = sqrt(S0.f16). Functional examples: V_SQRT_F16(0xfc00) => 0xfe00    // sqrt(-INF) = NAN V_SQRT_F16(0x8000) => 0x8000    // sqrt(-0.0) = -0 V_SQRT_F16(0x0000) => 0x0000    // sqrt(+0.0) = +0 V_SQRT_F16(0x4400) => 0x4000    // sqrt(+4.0) = +2.0 V_SQRT_F16(0x7c00) => 0x7c00    // sqrt(+INF) = +INF"
                },
                {
                    "opcode": "86",
                    "name": "V_RSQ_F16",
                    "short": "Reciprocal square root with IEEE rules",
                    "description": "Reciprocal square root with IEEE rules.  0.51ULP accuracy, denormals are supported. D.f16 = 1.0 / sqrt(S0.f16). Functional examples: V_RSQ_F16(0xfc00) => 0xfe00    // rsq(-INF) = NAN V_RSQ_F16(0x8000) => 0xfc00    // rsq(-0.0) = -INF V_RSQ_F16(0x0000) => 0x7c00    // rsq(+0.0) = +INF V_RSQ_F16(0x4400) => 0x3800    // rsq(+4.0) = +0.5 V_RSQ_F16(0x7c00) => 0x0000    // rsq(+INF) = +0"
                },
                {
                    "opcode": "87",
                    "name": "V_LOG_F16",
                    "short": "Base 2 logarithm",
                    "description": "Base 2 logarithm.  0.51ULP accuracy, denormals are supported. D.f16 = log2(S0.f). Functional examples: V_LOG_F16(0xfc00) => 0xfe00    // log(-INF) = NAN V_LOG_F16(0xbc00) => 0xfe00    // log(-1.0) = NAN V_LOG_F16(0x8000) => 0xfc00    // log(-0.0) = -INF V_LOG_F16(0x0000) => 0xfc00    // log(+0.0) = -INF V_LOG_F16(0x3c00) => 0x0000    // log(+1.0) = 0 V_LOG_F16(0x7c00) => 0x7c00    // log(+INF) = +INF"
                },
                {
                    "opcode": "88",
                    "name": "V_EXP_F16",
                    "short": "Base 2 exponentiation",
                    "description": "Base 2 exponentiation.  0.51ULP accuracy, denormals are supported. D.f16 = pow(2.0, S0.f16). Functional examples: V_EXP_F16(0xfc00) => 0x0000// exp(-INF) = 0 V_EXP_F16(0x8000) => 0x3c00// exp(-0.0) = 1 V_EXP_F16(0x7c00) => 0x7c00// exp(+INF) = +INF"
                },
                {
                    "opcode": "89",
                    "name": "V_FREXP_MANT_F16",
                    "short": "Returns binary significand of half precision float input, such that S0",
                    "description": "Returns binary significand of half precision float input, such that S0.f16 = significand * (2 ** exponent).  Result range is in (-1.0,-0.5][0.5,1.0) in normal cases.  See also V_FREXP_EXP_I16_F16, which returns integer exponent.  See the C library function frexp() for more information. if(S0.f16 == +-INF || S0.f16 == NAN) then D.f16 = S0.f16; else D.f16 = Mantissa(S0.f16); endif."
                },
                {
                    "opcode": "90",
                    "name": "V_FREXP_EXP_I16_F1",
                    "short": "Returns exponent of half precision float input, such that S0",
                    "description": "Returns exponent of half precision float input, such that S0.f16 6 = significand * (2 ** exponent). See also V_FREXP_MANT_F16, which returns the significand.  See the C library function frexp() for more information. if(S0.f16 == +-INF || S0.f16 == NAN) then D.i = 0; else D.i = TwosComplement(Exponent(S0.f16) - 15 + 1); endif."
                },
                {
                    "opcode": "91",
                    "name": "V_FLOOR_F16",
                    "short": "Round down to previous whole integer",
                    "description": "Round down to previous whole integer. D.f16 = trunc(S0.f16); if(S0.f16 < 0.0f && S0.f16 != D.f16) then D.f16 -= 1.0; endif."
                },
                {
                    "opcode": "92",
                    "name": "V_CEIL_F16",
                    "short": "Round up to next whole integer",
                    "description": "Round up to next whole integer. D.f16 = trunc(S0.f16); if(S0.f16 > 0.0f && S0.f16 != D.f16) then D.f16 += 1.0; endif."
                },
                {
                    "opcode": "93",
                    "name": "V_TRUNC_F16",
                    "short": "Return integer part of S0",
                    "description": "Return integer part of S0.f16, round-to-zero semantics. D.f16 = trunc(S0.f16)."
                },
                {
                    "opcode": "94",
                    "name": "V_RNDNE_F16",
                    "short": "Round-to-nearest-even semantics",
                    "description": "Round-to-nearest-even semantics. D.f16 = floor(S0.f16 + 0.5); if(floor(S0.f16) is even && fract(S0.f16) == 0.5) then D.f16 -= 1.0; endif."
                },
                {
                    "opcode": "95",
                    "name": "V_FRACT_F16",
                    "short": "Return fractional portion of a number",
                    "description": "Return fractional portion of a number.  0.5ULP accuracy, denormals are accepted. D.f16 = S0.f16 + -floor(S0.f16). NOTE: This complies with the DX specification of fract where the function behaves like an extension of integer modulus; be aware this may differ from how fract() is defined in other domains. For example: fract(-1.2) = 0.8 in DX."
                },
                {
                    "opcode": "96",
                    "name": "V_SIN_F16",
                    "short": "Trigonometric sine",
                    "description": "Trigonometric sine.  Denormals are supported. D.f16 = sin(S0.f16 * 2 * PI). Functional examples: V_SIN_F16(0xfc00) => 0xfe00    // sin(-INF) = NAN V_SIN_F16(0xfbff) => 0x0000    // Most negative finite FP16 V_SIN_F16(0x8000) => 0x8000    // sin(-0.0) = -0 V_SIN_F16(0x3400) => 0x3c00    // sin(0.25) = 1 V_SIN_F16(0x7bff) => 0x0000    // Most positive finite FP16 V_SIN_F16(0x7c00) => 0xfe00    // sin(+INF) = NAN"
                },
                {
                    "opcode": "97",
                    "name": "V_COS_F16",
                    "short": "Trigonometric cosine",
                    "description": "Trigonometric cosine.  Denormals are supported. D.f16 = cos(S0.f16 * 2 * PI). Functional examples: V_COS_F16(0xfc00) => 0xfe00    // cos(-INF) = NAN V_COS_F16(0xfbff) => 0x3c00    // Most negative finite FP16 V_COS_F16(0x8000) => 0x3c00    // cos(-0.0) = 1 V_COS_F16(0x3400) => 0x0000    // cos(0.25) = 0 V_COS_F16(0x7bff) => 0x3c00    // Most positive finite FP16 V_COS_F16(0x7c00) => 0xfe00    // cos(+INF) = NAN"
                },
                {
                    "opcode": "98",
                    "name": "V_SAT_PK_U8_I16",
                    "short": "Packed 8-bit saturating add",
                    "description": "Packed 8-bit saturating add. D.u32 = {16'b0, sat8(S.u[31:16]), sat8(S.u[15:0])}."
                },
                {
                    "opcode": "99",
                    "name": "V_CVT_NORM_I16_F16",
                    "short": " Convert from an FP16 float to a signed normalized short",
                    "description": " Convert from an FP16 float to a signed normalized short.  0.5ULP accuracy, supports rounding, exception flags and saturation, denormals are supported. D.i16 = flt16_to_snorm16(S.f16)."
                },
                {
                    "opcode": "100",
                    "name": "V_CVT_NORM_U16_F16",
                    "short": " Convert from an FP16 float to an unsigned normalized short",
                    "description": " Convert from an FP16 float to an unsigned normalized short. 0.5ULP accuracy, supports rounding, exception flags and saturation, denormals are supported. D.u16 = flt16_to_unorm16(S.f16)."
                },
                {
                    "opcode": "101",
                    "name": "V_SWAP_B32",
                    "short": "Swap operands",
                    "description": "Swap operands.  Input and output modifiers not supported; this is an untyped operation. tmp = D.u; D.u = S0.u; S0.u = tmp."
                }
            ]
        },
        {
            "key": "vopc",
            "name": "VOPC Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "V_CMP_F_F32",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "1",
                    "name": "V_CMP_LT_F32",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "2",
                    "name": "V_CMP_EQ_F32",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "3",
                    "name": "V_CMP_LE_F32",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "4",
                    "name": "V_CMP_GT_F32",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "5",
                    "name": "V_CMP_LG_F32",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "6",
                    "name": "V_CMP_GE_F32",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "7",
                    "name": "V_CMP_O_F32",
                    "short": "D[threadId] = (!isNan(S0) && !isNan(S1))",
                    "description": "D[threadId] = (!isNan(S0) && !isNan(S1)). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "8",
                    "name": "V_CMP_U_F32",
                    "short": "D[threadId] = (isNan(S0)  ||  isNan(S1))",
                    "description": "D[threadId] = (isNan(S0)  ||  isNan(S1)). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "9",
                    "name": "V_CMP_NGE_F32",
                    "short": "D[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <",
                    "description": "D[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "10",
                    "name": "V_CMP_NLG_F32",
                    "short": "D[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==",
                    "description": "D[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "11",
                    "name": "V_CMP_NGT_F32",
                    "short": "D[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=",
                    "description": "D[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "12",
                    "name": "V_CMP_NLE_F32",
                    "short": "D[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >",
                    "description": "D[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "13",
                    "name": "V_CMP_NEQ_F32",
                    "short": "D[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=",
                    "description": "D[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "14",
                    "name": "V_CMP_NLT_F32",
                    "short": "D[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=",
                    "description": "D[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "15",
                    "name": "V_CMP_TRU_F32",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "16",
                    "name": "V_CMPX_F_F32",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "17",
                    "name": "V_CMPX_LT_F32",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "18",
                    "name": "V_CMPX_EQ_F32",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "19",
                    "name": "V_CMPX_LE_F32",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "20",
                    "name": "V_CMPX_GT_F32",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "21",
                    "name": "V_CMPX_LG_F32",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "22",
                    "name": "V_CMPX_GE_F32",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "23",
                    "name": "V_CMPX_O_F32",
                    "short": "EXEC[threadId] = (!isNan(S0) && !isNan(S1))",
                    "description": "EXEC[threadId] = (!isNan(S0) && !isNan(S1))."
                },
                {
                    "opcode": "24",
                    "name": "V_CMPX_U_F32",
                    "short": "EXEC[threadId] = (isNan(S0)  ||  isNan(S1))",
                    "description": "EXEC[threadId] = (isNan(S0)  ||  isNan(S1))."
                },
                {
                    "opcode": "25",
                    "name": "V_CMPX_NGE_F32",
                    "short": "EXEC[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <",
                    "description": "EXEC[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <."
                },
                {
                    "opcode": "26",
                    "name": "V_CMPX_NLG_F32",
                    "short": "EXEC[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==",
                    "description": "EXEC[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==."
                },
                {
                    "opcode": "27",
                    "name": "V_CMPX_NGT_F32",
                    "short": "EXEC[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=",
                    "description": "EXEC[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=."
                },
                {
                    "opcode": "28",
                    "name": "V_CMPX_NLE_F32",
                    "short": "EXEC[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >",
                    "description": "EXEC[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >."
                },
                {
                    "opcode": "29",
                    "name": "V_CMPX_NEQ_F32",
                    "short": "EXEC[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=",
                    "description": "EXEC[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=."
                },
                {
                    "opcode": "30",
                    "name": "V_CMPX_NLT_F32",
                    "short": "EXEC[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=",
                    "description": "EXEC[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=."
                },
                {
                    "opcode": "31",
                    "name": "V_CMPX_TRU_F32",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                },
                {
                    "opcode": "32",
                    "name": "V_CMP_F_F64",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "33",
                    "name": "V_CMP_LT_F64",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "34",
                    "name": "V_CMP_EQ_F64",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "35",
                    "name": "V_CMP_LE_F64",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "36",
                    "name": "V_CMP_GT_F64",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "37",
                    "name": "V_CMP_LG_F64",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "38",
                    "name": "V_CMP_GE_F64",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "39",
                    "name": "V_CMP_O_F64",
                    "short": "D[threadId] = (!isNan(S0) && !isNan(S1))",
                    "description": "D[threadId] = (!isNan(S0) && !isNan(S1)). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "40",
                    "name": "V_CMP_U_F64",
                    "short": "D[threadId] = (isNan(S0)  ||  isNan(S1))",
                    "description": "D[threadId] = (isNan(S0)  ||  isNan(S1)). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "41",
                    "name": "V_CMP_NGE_F64",
                    "short": "D[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <",
                    "description": "D[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "42",
                    "name": "V_CMP_NLG_F64",
                    "short": "D[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==",
                    "description": "D[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "43",
                    "name": "V_CMP_NGT_F64",
                    "short": "D[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=",
                    "description": "D[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "44",
                    "name": "V_CMP_NLE_F64",
                    "short": "D[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >",
                    "description": "D[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "45",
                    "name": "V_CMP_NEQ_F64",
                    "short": "D[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=",
                    "description": "D[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "46",
                    "name": "V_CMP_NLT_F64",
                    "short": "D[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=",
                    "description": "D[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "47",
                    "name": "V_CMP_TRU_F64",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "48",
                    "name": "V_CMPX_F_F64",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "49",
                    "name": "V_CMPX_LT_F64",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "50",
                    "name": "V_CMPX_EQ_F64",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "51",
                    "name": "V_CMPX_LE_F64",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "52",
                    "name": "V_CMPX_GT_F64",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "53",
                    "name": "V_CMPX_LG_F64",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "54",
                    "name": "V_CMPX_GE_F64",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "55",
                    "name": "V_CMPX_O_F64",
                    "short": "EXEC[threadId] = (!isNan(S0) && !isNan(S1))",
                    "description": "EXEC[threadId] = (!isNan(S0) && !isNan(S1))."
                },
                {
                    "opcode": "56",
                    "name": "V_CMPX_U_F64",
                    "short": "EXEC[threadId] = (isNan(S0)  ||  isNan(S1))",
                    "description": "EXEC[threadId] = (isNan(S0)  ||  isNan(S1))."
                },
                {
                    "opcode": "57",
                    "name": "V_CMPX_NGE_F64",
                    "short": "EXEC[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <",
                    "description": "EXEC[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <."
                },
                {
                    "opcode": "58",
                    "name": "V_CMPX_NLG_F64",
                    "short": "EXEC[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==",
                    "description": "EXEC[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==."
                },
                {
                    "opcode": "59",
                    "name": "V_CMPX_NGT_F64",
                    "short": "EXEC[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=",
                    "description": "EXEC[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=."
                },
                {
                    "opcode": "60",
                    "name": "V_CMPX_NLE_F64",
                    "short": "EXEC[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >",
                    "description": "EXEC[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >."
                },
                {
                    "opcode": "61",
                    "name": "V_CMPX_NEQ_F64",
                    "short": "EXEC[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=",
                    "description": "EXEC[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=."
                },
                {
                    "opcode": "62",
                    "name": "V_CMPX_NLT_F64",
                    "short": "EXEC[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=",
                    "description": "EXEC[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=."
                },
                {
                    "opcode": "63",
                    "name": "V_CMPX_TRU_F64",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                },
                {
                    "opcode": "128",
                    "name": "V_CMP_F_I32",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "129",
                    "name": "V_CMP_LT_I32",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "130",
                    "name": "V_CMP_EQ_I32",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "131",
                    "name": "V_CMP_LE_I32",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "132",
                    "name": "V_CMP_GT_I32",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "133",
                    "name": "V_CMP_NE_I32",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "134",
                    "name": "V_CMP_GE_I32",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "135",
                    "name": "V_CMP_T_I32",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "136",
                    "name": "V_CMP_CLASS_F32",
                    "short": "VCC = IEEE numeric class function specified in S1",
                    "description": "VCC = IEEE numeric class function specified in S1.u, performed on S0.f. The function reports true if the floating point value is *any* of the numeric types selected in S1.u according to the following list: S1.u[0] -- value is a signaling NaN. S1.u[1] -- value is a quiet NaN. S1.u[2] -- value is negative infinity. S1.u[3] -- value is a negative normal value. S1.u[4] -- value is a negative denormal value. S1.u[5] -- value is negative zero. S1.u[6] -- value is positive zero. S1.u[7] -- value is a positive denormal value. S1.u[8] -- value is a positive normal value. S1.u[9] -- value is positive infinity."
                },
                {
                    "opcode": "137",
                    "name": "V_CMP_LT_I16",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "138",
                    "name": "V_CMP_EQ_I16",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "139",
                    "name": "V_CMP_LE_I16",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "140",
                    "name": "V_CMP_GT_I16",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "141",
                    "name": "V_CMP_NE_I16",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "142",
                    "name": "V_CMP_GE_I16",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "143",
                    "name": "V_CMP_CLASS_F16",
                    "short": "VCC = IEEE numeric class function specified in S1",
                    "description": "VCC = IEEE numeric class function specified in S1.u, performed on S0.f16. Note that the S1 has a format of f16 since floating point literal constants are interpreted as 16 bit value for this opcode. The function reports true if the floating point value is *any* of the numeric types selected in S1.u according to the following list: S1.u[0] -- value is a signaling NaN. S1.u[1] -- value is a quiet NaN. S1.u[2] -- value is negative infinity. S1.u[3] -- value is a negative normal value. S1.u[4] -- value is a negative denormal value. S1.u[5] -- value is negative zero. S1.u[6] -- value is positive zero. S1.u[7] -- value is a positive denormal value. S1.u[8] -- value is a positive normal value. S1.u[9] -- value is positive infinity."
                },
                {
                    "opcode": "144",
                    "name": "V_CMPX_F_I32",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "145",
                    "name": "V_CMPX_LT_I32",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "146",
                    "name": "V_CMPX_EQ_I32",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "147",
                    "name": "V_CMPX_LE_I32",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "148",
                    "name": "V_CMPX_GT_I32",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "149",
                    "name": "V_CMPX_NE_I32",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "150",
                    "name": "V_CMPX_GE_I32",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "151",
                    "name": "V_CMPX_T_I32",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                },
                {
                    "opcode": "152",
                    "name": "V_CMPX_CLASS_F32",
                    "short": "EXEC = IEEE numeric class function specified in S1",
                    "description": "EXEC = IEEE numeric class function specified in S1.u, performed on S0.f. The function reports true if the floating point value is *any* of the numeric types selected in S1.u according to the following list: S1.u[0] -- value is a signaling NaN. S1.u[1] -- value is a quiet NaN. S1.u[2] -- value is negative infinity. S1.u[3] -- value is a negative normal value. S1.u[4] -- value is a negative denormal value. S1.u[5] -- value is negative zero. S1.u[6] -- value is positive zero. S1.u[7] -- value is a positive denormal value. S1.u[8] -- value is a positive normal value. S1.u[9] -- value is positive infinity."
                },
                {
                    "opcode": "153",
                    "name": "V_CMPX_LT_I16",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "154",
                    "name": "V_CMPX_EQ_I16",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "155",
                    "name": "V_CMPX_LE_I16",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "156",
                    "name": "V_CMPX_GT_I16",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "157",
                    "name": "V_CMPX_NE_I16",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "158",
                    "name": "V_CMPX_GE_I16",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "159",
                    "name": "V_CMPX_CLASS_F16",
                    "short": "EXEC = IEEE numeric class function specified in S1",
                    "description": "EXEC = IEEE numeric class function specified in S1.u, performed on S0.f16. Note that the S1 has a format of f16 since floating point literal constants are interpreted as 16 bit value for this opcode. The function reports true if the floating point value is *any* of the numeric types selected in S1.u according to the following list: S1.u[0] -- value is a signaling NaN. S1.u[1] -- value is a quiet NaN. S1.u[2] -- value is negative infinity. S1.u[3] -- value is a negative normal value. S1.u[4] -- value is a negative denormal value. S1.u[5] -- value is negative zero. S1.u[6] -- value is positive zero. S1.u[7] -- value is a positive denormal value. S1.u[8] -- value is a positive normal value. S1.u[9] -- value is positive infinity."
                },
                {
                    "opcode": "160",
                    "name": "V_CMP_F_I64",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "161",
                    "name": "V_CMP_LT_I64",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "162",
                    "name": "V_CMP_EQ_I64",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "163",
                    "name": "V_CMP_LE_I64",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "164",
                    "name": "V_CMP_GT_I64",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "165",
                    "name": "V_CMP_NE_I64",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "166",
                    "name": "V_CMP_GE_I64",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "167",
                    "name": "V_CMP_T_I64",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "168",
                    "name": "V_CMP_CLASS_F64",
                    "short": "VCC = IEEE numeric class function specified in S1",
                    "description": "VCC = IEEE numeric class function specified in S1.u, performed on S0.d. The function reports true if the floating point value is *any* of the numeric types selected in S1.u according to the following list: S1.u[0] -- value is a signaling NaN. S1.u[1] -- value is a quiet NaN. S1.u[2] -- value is negative infinity. S1.u[3] -- value is a negative normal value. S1.u[4] -- value is a negative denormal value. S1.u[5] -- value is negative zero. S1.u[6] -- value is positive zero. S1.u[7] -- value is a positive denormal value. S1.u[8] -- value is a positive normal value. S1.u[9] -- value is positive infinity."
                },
                {
                    "opcode": "169",
                    "name": "V_CMP_LT_U16",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "170",
                    "name": "V_CMP_EQ_U16",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "171",
                    "name": "V_CMP_LE_U16",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "172",
                    "name": "V_CMP_GT_U16",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "173",
                    "name": "V_CMP_NE_U16",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "174",
                    "name": "V_CMP_GE_U16",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "176",
                    "name": "V_CMPX_F_I64",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "177",
                    "name": "V_CMPX_LT_I64",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "178",
                    "name": "V_CMPX_EQ_I64",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "179",
                    "name": "V_CMPX_LE_I64",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "180",
                    "name": "V_CMPX_GT_I64",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "181",
                    "name": "V_CMPX_NE_I64",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "182",
                    "name": "V_CMPX_GE_I64",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "183",
                    "name": "V_CMPX_T_I64",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                },
                {
                    "opcode": "184",
                    "name": "V_CMPX_CLASS_F64",
                    "short": "EXEC = IEEE numeric class function specified in S1",
                    "description": "EXEC = IEEE numeric class function specified in S1.u, performed on S0.d. The function reports true if the floating point value is *any* of the numeric types selected in S1.u according to the following list: S1.u[0] -- value is a signaling NaN. S1.u[1] -- value is a quiet NaN. S1.u[2] -- value is negative infinity. S1.u[3] -- value is a negative normal value. S1.u[4] -- value is a negative denormal value. S1.u[5] -- value is negative zero. S1.u[6] -- value is positive zero. S1.u[7] -- value is a positive denormal value. S1.u[8] -- value is a positive normal value. S1.u[9] -- value is positive infinity."
                },
                {
                    "opcode": "185",
                    "name": "V_CMPX_LT_U16",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "186",
                    "name": "V_CMPX_EQ_U16",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "187",
                    "name": "V_CMPX_LE_U16",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "188",
                    "name": "V_CMPX_GT_U16",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "189",
                    "name": "V_CMPX_NE_U16",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "190",
                    "name": "V_CMPX_GE_U16",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "192",
                    "name": "V_CMP_F_U32",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "193",
                    "name": "V_CMP_LT_U32",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "194",
                    "name": "V_CMP_EQ_U32",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "195",
                    "name": "V_CMP_LE_U32",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "196",
                    "name": "V_CMP_GT_U32",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "197",
                    "name": "V_CMP_NE_U32",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "198",
                    "name": "V_CMP_GE_U32",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "199",
                    "name": "V_CMP_T_U32",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "200",
                    "name": "V_CMP_F_F16",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "201",
                    "name": "V_CMP_LT_F16",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "202",
                    "name": "V_CMP_EQ_F16",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "203",
                    "name": "V_CMP_LE_F16",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "204",
                    "name": "V_CMP_GT_F16",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "205",
                    "name": "V_CMP_LG_F16",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "206",
                    "name": "V_CMP_GE_F16",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "207",
                    "name": "V_CMP_O_F16",
                    "short": "D[threadId] = (!isNan(S0) && !isNan(S1))",
                    "description": "D[threadId] = (!isNan(S0) && !isNan(S1)). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "208",
                    "name": "V_CMPX_F_U32",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "209",
                    "name": "V_CMPX_LT_U32",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "210",
                    "name": "V_CMPX_EQ_U32",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "211",
                    "name": "V_CMPX_LE_U32",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "212",
                    "name": "V_CMPX_GT_U32",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "213",
                    "name": "V_CMPX_NE_U32",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "214",
                    "name": "V_CMPX_GE_U32",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "215",
                    "name": "V_CMPX_T_U32",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                },
                {
                    "opcode": "216",
                    "name": "V_CMPX_F_F16",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "217",
                    "name": "V_CMPX_LT_F16",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "218",
                    "name": "V_CMPX_EQ_F16",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "219",
                    "name": "V_CMPX_LE_F16",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "220",
                    "name": "V_CMPX_GT_F16",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "221",
                    "name": "V_CMPX_LG_F16",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "222",
                    "name": "V_CMPX_GE_F16",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "223",
                    "name": "V_CMPX_O_F16",
                    "short": "EXEC[threadId] = (!isNan(S0) && !isNan(S1))",
                    "description": "EXEC[threadId] = (!isNan(S0) && !isNan(S1))."
                },
                {
                    "opcode": "224",
                    "name": "V_CMP_F_U64",
                    "short": "D[threadId] = 0",
                    "description": "D[threadId] = 0. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "225",
                    "name": "V_CMP_LT_U64",
                    "short": "D[threadId] = (S0 < S1)",
                    "description": "D[threadId] = (S0 < S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "226",
                    "name": "V_CMP_EQ_U64",
                    "short": "D[threadId] = (S0 == S1)",
                    "description": "D[threadId] = (S0 == S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "227",
                    "name": "V_CMP_LE_U64",
                    "short": "D[threadId] = (S0 <= S1)",
                    "description": "D[threadId] = (S0 <= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "228",
                    "name": "V_CMP_GT_U64",
                    "short": "D[threadId] = (S0 > S1)",
                    "description": "D[threadId] = (S0 > S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "229",
                    "name": "V_CMP_NE_U64",
                    "short": "D[threadId] = (S0 <> S1)",
                    "description": "D[threadId] = (S0 <> S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "230",
                    "name": "V_CMP_GE_U64",
                    "short": "D[threadId] = (S0 >= S1)",
                    "description": "D[threadId] = (S0 >= S1). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "231",
                    "name": "V_CMP_T_U64",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "232",
                    "name": "V_CMP_U_F16",
                    "short": "D[threadId] = (isNan(S0)  ||  isNan(S1))",
                    "description": "D[threadId] = (isNan(S0)  ||  isNan(S1)). // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "233",
                    "name": "V_CMP_NGE_F16",
                    "short": "D[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <",
                    "description": "D[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "234",
                    "name": "V_CMP_NLG_F16",
                    "short": "D[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==",
                    "description": "D[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "235",
                    "name": "V_CMP_NGT_F16",
                    "short": "D[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=",
                    "description": "D[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "236",
                    "name": "V_CMP_NLE_F16",
                    "short": "D[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >",
                    "description": "D[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "237",
                    "name": "V_CMP_NEQ_F16",
                    "short": "D[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=",
                    "description": "D[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "238",
                    "name": "V_CMP_NLT_F16",
                    "short": "D[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=",
                    "description": "D[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "239",
                    "name": "V_CMP_TRU_F16",
                    "short": "D[threadId] = 1",
                    "description": "D[threadId] = 1. // D = VCC in VOPC encoding."
                },
                {
                    "opcode": "240",
                    "name": "V_CMPX_F_U64",
                    "short": "EXEC[threadId] = 0",
                    "description": "EXEC[threadId] = 0."
                },
                {
                    "opcode": "241",
                    "name": "V_CMPX_LT_U64",
                    "short": "EXEC[threadId] = (S0 < S1)",
                    "description": "EXEC[threadId] = (S0 < S1)."
                },
                {
                    "opcode": "242",
                    "name": "V_CMPX_EQ_U64",
                    "short": "EXEC[threadId] = (S0 == S1)",
                    "description": "EXEC[threadId] = (S0 == S1)."
                },
                {
                    "opcode": "243",
                    "name": "V_CMPX_LE_U64",
                    "short": "EXEC[threadId] = (S0 <= S1)",
                    "description": "EXEC[threadId] = (S0 <= S1)."
                },
                {
                    "opcode": "244",
                    "name": "V_CMPX_GT_U64",
                    "short": "EXEC[threadId] = (S0 > S1)",
                    "description": "EXEC[threadId] = (S0 > S1)."
                },
                {
                    "opcode": "245",
                    "name": "V_CMPX_NE_U64",
                    "short": "EXEC[threadId] = (S0 <> S1)",
                    "description": "EXEC[threadId] = (S0 <> S1)."
                },
                {
                    "opcode": "246",
                    "name": "V_CMPX_GE_U64",
                    "short": "EXEC[threadId] = (S0 >= S1)",
                    "description": "EXEC[threadId] = (S0 >= S1)."
                },
                {
                    "opcode": "247",
                    "name": "V_CMPX_T_U64",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                },
                {
                    "opcode": "248",
                    "name": "V_CMPX_U_F16",
                    "short": "EXEC[threadId] = (isNan(S0)  ||  isNan(S1))",
                    "description": "EXEC[threadId] = (isNan(S0)  ||  isNan(S1))."
                },
                {
                    "opcode": "249",
                    "name": "V_CMPX_NGE_F16",
                    "short": "EXEC[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <",
                    "description": "EXEC[threadId] = !(S0 >= S1) // With NAN inputs this is not the same operation as <."
                },
                {
                    "opcode": "250",
                    "name": "V_CMPX_NLG_F16",
                    "short": "EXEC[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==",
                    "description": "EXEC[threadId] = !(S0 <> S1) // With NAN inputs this is not the same operation as ==."
                },
                {
                    "opcode": "251",
                    "name": "V_CMPX_NGT_F16",
                    "short": "EXEC[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=",
                    "description": "EXEC[threadId] = !(S0 > S1) // With NAN inputs this is not the same operation as <=."
                },
                {
                    "opcode": "252",
                    "name": "V_CMPX_NLE_F16",
                    "short": "EXEC[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >",
                    "description": "EXEC[threadId] = !(S0 <= S1) // With NAN inputs this is not the same operation as >."
                },
                {
                    "opcode": "253",
                    "name": "V_CMPX_NEQ_F16",
                    "short": "EXEC[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=",
                    "description": "EXEC[threadId] = !(S0 == S1) // With NAN inputs this is not the same operation as !=."
                },
                {
                    "opcode": "254",
                    "name": "V_CMPX_NLT_F16",
                    "short": "EXEC[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=",
                    "description": "EXEC[threadId] = !(S0 < S1) // With NAN inputs this is not the same operation as >=."
                },
                {
                    "opcode": "255",
                    "name": "V_CMPX_TRU_F16",
                    "short": "EXEC[threadId] = 1",
                    "description": "EXEC[threadId] = 1."
                }
            ]
        },
        {
            "key": "vop3p",
            "name": "VOP3P Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "V_PK_MAD_I16",
                    "short": "Packed multiply-add on signed shorts",
                    "description": "Packed multiply-add on signed shorts. D.i[31:16] = S0.i[31:16] * S1.i[31:16] + S2.i[31:16]; D.i[15:0]  = S0.i[15:0]  * S1.i[15:0]  + S2.i[15:0]."
                },
                {
                    "opcode": "1",
                    "name": "V_PK_MUL_LO_U16",
                    "short": "Packed multiply on unsigned shorts",
                    "description": "Packed multiply on unsigned shorts. D.u[31:16] = S0.u[31:16] * S1.u[31:16]; D.u[15:0]  = S0.u[15:0]  * S1.u[15:0]."
                },
                {
                    "opcode": "2",
                    "name": "V_PK_ADD_I16",
                    "short": "Packed addition on signed shorts",
                    "description": "Packed addition on signed shorts. D.i[31:16] = S0.i[31:16] + S1.i[31:16]; D.i[15:0]  = S0.i[15:0]  + S1.i[15:0]."
                },
                {
                    "opcode": "3",
                    "name": "V_PK_SUB_I16",
                    "short": "Packed subtraction on signed shorts",
                    "description": "Packed subtraction on signed shorts.  The second operand is subtracted from the first. D.i[31:16] = S0.i[31:16] - S1.i[31:16]; D.i[15:0]  = S0.i[15:0]  - S1.i[15:0]."
                },
                {
                    "opcode": "4",
                    "name": "V_PK_LSHLREV_B16",
                    "short": "Packed logical shift left",
                    "description": "Packed logical shift left.  The shift count is in the first operand. D.u[31:16] = S1.u[31:16] << S0.u[19:16]; D.u[15:0]  = S1.u[15:0]  << S0.u[3:0]."
                },
                {
                    "opcode": "5",
                    "name": "V_PK_LSHRREV_B16",
                    "short": "Packed logical shift right",
                    "description": "Packed logical shift right.  The shift count is in the first operand. D.u[31:16] = S1.u[31:16] >> S0.u[19:16]; D.u[15:0]  = S1.u[15:0]  >> S0.u[3:0]."
                },
                {
                    "opcode": "6",
                    "name": "V_PK_ASHRREV_I16",
                    "short": "Packed arithmetic shift right (preserve sign bit)",
                    "description": "Packed arithmetic shift right (preserve sign bit).  The shift count is in the first operand. D.i[31:16] = S1.i[31:16] >> S0.i[19:16]; D.i[15:0]  = S1.i[15:0]  >> S0.i[3:0]."
                },
                {
                    "opcode": "7",
                    "name": "V_PK_MAX_I16",
                    "short": "Packed maximum of signed shorts",
                    "description": "Packed maximum of signed shorts. D.i[31:16] = (S0.i[31:16] >= S1.i[31:16]) ? S0.i[31:16] : S1.i[31:16]; D.i[15:0]  = (S0.i[15:0]  >= S1.i[15:0])  ? S0.i[15:0]  : S1.i[15:0]."
                },
                {
                    "opcode": "8",
                    "name": "V_PK_MIN_I16",
                    "short": "Packed minimum of signed shorts",
                    "description": "Packed minimum of signed shorts. D.i[31:16] = (S0.i[31:16] < S1.i[31:16]) ? S0.i[31:16] : S1.i[31:16]; D.i[15:0]  = (S0.i[15:0]  < S1.i[15:0])  ? S0.i[15:0]  : S1.i[15:0]."
                },
                {
                    "opcode": "9",
                    "name": "V_PK_MAD_U16",
                    "short": "Packed multiply-add on unsigned shorts",
                    "description": "Packed multiply-add on unsigned shorts. D.u[31:16] = S0.u[31:16] * S1.u[31:16] + S2.u[31:16]; D.u[15:0]  = S0.u[15:0]  * S1.u[15:0]  + S2.u[15:0]."
                },
                {
                    "opcode": "10",
                    "name": "V_PK_ADD_U16",
                    "short": "Packed addition on unsigned shorts",
                    "description": "Packed addition on unsigned shorts. D.u[31:16] = S0.u[31:16] + S1.u[31:16]; D.u[15:0]  = S0.u[15:0]  + S1.u[15:0]."
                },
                {
                    "opcode": "11",
                    "name": "V_PK_SUB_U16",
                    "short": "Packed subtraction on unsigned shorts",
                    "description": "Packed subtraction on unsigned shorts.  The second operand is subtracted from the first. D.u[31:16] = S0.u[31:16] - S1.u[31:16]; D.u[15:0]  = S0.u[15:0]  - S1.u[15:0]."
                },
                {
                    "opcode": "12",
                    "name": "V_PK_MAX_U16",
                    "short": "Packed maximum of unsigned shorts",
                    "description": "Packed maximum of unsigned shorts. D.u[31:16] = (S0.u[31:16] >= S1.u[31:16]) ? S0.u[31:16] : S1.u[31:16]; D.u[15:0]  = (S0.u[15:0]  >= S1.u[15:0])  ? S0.u[15:0]  : S1.u[15:0]."
                },
                {
                    "opcode": "13",
                    "name": "V_PK_MIN_U16",
                    "short": "Packed minimum of unsigned shorts",
                    "description": "Packed minimum of unsigned shorts. D.u[31:16] = (S0.u[31:16] < S1.u[31:16]) ? S0.u[31:16] : S1.u[31:16]; D.u[15:0]  = (S0.u[15:0]  < S1.u[15:0])  ? S0.u[15:0]  : S1.u[15:0]."
                },
                {
                    "opcode": "14",
                    "name": "V_PK_FMA_F16",
                    "short": "Packed fused-multiply-add of FP16 values",
                    "description": "Packed fused-multiply-add of FP16 values. D.f[31:16] = S0.f[31:16] * S1.f[31:16] + S2.f[31:16]; D.f[15:0]  = S0.f[15:0]  * S1.f[15:0]  + S2.f[15:0]."
                },
                {
                    "opcode": "15",
                    "name": "V_PK_ADD_F16",
                    "short": "Packed addition of FP16 values",
                    "description": "Packed addition of FP16 values. D.f[31:16] = S0.f[31:16] + S1.f[31:16]; D.f[15:0]  = S0.f[15:0]  + S1.f[15:0]."
                },
                {
                    "opcode": "16",
                    "name": "V_PK_MUL_F16",
                    "short": "Packed multiply of FP16 values",
                    "description": "Packed multiply of FP16 values. D.f[31:16] = S0.f[31:16] * S1.f[31:16]; D.f[15:0]  = S0.f[15:0]  * S1.f[15:0]."
                },
                {
                    "opcode": "17",
                    "name": "V_PK_MIN_F16",
                    "short": "Packed minimum of FP16 values",
                    "description": "Packed minimum of FP16 values. D.f[31:16] = min(S0.f[31:16], S1.f[31:16]); D.f[15:0]  = min(S0.f[15:0], S1.u[15:0])."
                },
                {
                    "opcode": "18",
                    "name": "V_PK_MAX_F16",
                    "short": "Packed maximum of FP16 values",
                    "description": "Packed maximum of FP16 values. D.f[31:16] = max(S0.f[31:16], S1.f[31:16]); D.f[15:0]  = max(S0.f[15:0], S1.f[15:0])."
                },
                {
                    "opcode": "19",
                    "name": "V_DOT2_F32_F16",
                    "short": "Dot product of packed FP16 values",
                    "description": "Dot product of packed FP16 values. D.f32 = S0.f16[0] * S1.f16[0] + S0.f16[1] * S1.f16[1] + S2.f32."
                },
                {
                    "opcode": "20",
                    "name": "V_DOT2_I32_I16",
                    "short": "Dot product of signed shorts",
                    "description": "Dot product of signed shorts. D.i32 = S0.i16[0] * S1.i16[0] + S0.i16[1] * S1.i16[1] + S2.i32."
                },
                {
                    "opcode": "21",
                    "name": "V_DOT2_U32_U16",
                    "short": "Dot product of unsigned shorts",
                    "description": "Dot product of unsigned shorts. D.u32 = S0.u16[0] * S1.u16[0] + S0.u16[1] * S1.u16[1] + S2.u32."
                },
                {
                    "opcode": "22",
                    "name": "V_DOT4_I32_I8",
                    "short": "Dot product of signed bytes",
                    "description": "Dot product of signed bytes. D.i32 = S0.i8[0] * S1.i8[0] + S0.i8[1] * S1.i8[1] + S0.i8[2] * S1.i8[2] + S0.i8[3] * S1.i8[3] + S2.i32."
                },
                {
                    "opcode": "23",
                    "name": "V_DOT4_U32_U8",
                    "short": "Dot product of unsigned bytes",
                    "description": "Dot product of unsigned bytes. D.u32 = S0.u8[0] * S1.u8[0] + S0.u8[1] * S1.u8[1] + S0.u8[2] * S1.u8[2] + S0.u8[3] * S1.u8[3] + S2.u32."
                },
                {
                    "opcode": "24",
                    "name": "V_DOT8_I32_I4",
                    "short": "Dot product of signed nibbles",
                    "description": "Dot product of signed nibbles. D.i32 = S0.i4[0] * S1.i4[0] + S0.i4[1] * S1.i4[1] + S0.i4[2] * S1.i4[2] + S0.i4[3] * S1.i4[3] + S0.i4[4] * S1.i4[4] + S0.i4[5] * S1.i4[5] + S0.i4[6] * S1.i4[6] + S0.i4[7] * S1.i4[7] + S2.i32."
                },
                {
                    "opcode": "25",
                    "name": "V_DOT8_U32_U4",
                    "short": "Dot product of unsigned nibbles",
                    "description": "Dot product of unsigned nibbles. D.u32 = S0.u4[0] * S1.u4[0] + S0.u4[1] * S1.u4[1] + S0.u4[2] * S1.u4[2] + S0.u4[3] * S1.u4[3] + S0.u4[4] * S1.u4[4] + S0.u4[5] * S1.u4[5] + S0.u4[6] * S1.u4[6] + S0.u4[7] * S1.u4[7] + S2.u32."
                },
                {
                    "opcode": "32",
                    "name": "V_FMA_MIX_F32",
                    "short": "Fused-multiply-add of single-precision values with MIX encoding",
                    "description": "Fused-multiply-add of single-precision values with MIX encoding. Size and location of S0, S1 and S2 controlled by OPSEL: 0=src[31:0], 1=src[31:0], 2=src[15:0], 3=src[31:16].  Also, for MAD_MIX, the NEG_HI field acts instead as an absolute-value modifier. D.f[31:0] = S0.f * S1.f + S2.f."
                },
                {
                    "opcode": "33",
                    "name": "V_FMA_MIXLO_F16",
                    "short": "Fused-multiply-add of FP16 values with MIX encoding, result stored in low 16 bits of destination",
                    "description": "Fused-multiply-add of FP16 values with MIX encoding, result stored in low 16 bits of destination.  Size and location of S0, S1 and S2 controlled by OPSEL: 0=src[31:0], 1=src[31:0], 2=src[15:0], 3=src[31:16].  Also, for MAD_MIX, the NEG_HI field acts instead as an absolute-value modifier. D.f[15:0] = S0.f * S1.f + S2.f."
                }
            ]
        },
        {
            "key": "vinterp",
            "name": "VINTERP Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "V_INTERP_P1_F32",
                    "short": "Parameter interpolation, first pass",
                    "description": "Parameter interpolation, first pass. D.f32 = P10[S1.u32].f32 * S0.f32 + P0[S1.u3].f32. CAUTION: when in HALF_LDS mode, D must not be the same GPR as S; if D == S then data corruption will occur. NOTE: In textual representations the I/J VGPR is the first source and the attribute is the second source; however in the VOP3 encoding the attribute is stored in the src0 field and the VGPR is stored in the src1 field."
                },
                {
                    "opcode": "1",
                    "name": "V_INTERP_P2_F32",
                    "short": "Parameter interpolation, second pass",
                    "description": "Parameter interpolation, second pass. D.f = P20[S1.u] * S0.f + D.f. NOTE: In textual representations the I/J VGPR is the first source and the attribute is the second source; however in the VOP3 encoding the attribute is stored in the src0 field and the VGPR is stored in the src1 field."
                },
                {
                    "opcode": "2",
                    "name": "V_INTERP_MOV_F32",
                    "short": "Parameter load",
                    "description": "Parameter load. Used for custom interpolation in the shader. D.f = {P10,P20,P0}[S1.u]."
                }
            ]
        },
        {
            "key": "vop3a&vop3b",
            "name": "VOP3A & VOP3B Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "320",
                    "name": "V_FMA_LEGACY_F32",
                    "short": "Multiply and add single-precision values",
                    "description": "Multiply and add single-precision values.  Follows DX9 rules where 0.0 times anything produces 0.0 (this is not IEEE compliant). D.f = S0.f * S1.f + S2.f. // DX9 rules, 0.0 * x = 0.0"
                },
                {
                    "opcode": "322",
                    "name": "V_MAD_I32_I24",
                    "short": "Multiply two signed 24-bit integers, add a signed 32-bit integer and store the result as a signed 32-bit integer",
                    "description": "Multiply two signed 24-bit integers, add a signed 32-bit integer and store the result as a signed 32-bit integer. This opcode is as efficient as basic single-precision opcodes since it utilizes the single-precision floating point multiplier. D.i = S0.i[23:0] * S1.i[23:0] + S2.i."
                },
                {
                    "opcode": "323",
                    "name": "V_MAD_U32_U24",
                    "short": "Multiply two unsigned 24-bit integers, add an unsigned 32-bit integer and store the result as an unsigned 32-bit integer",
                    "description": "Multiply two unsigned 24-bit integers, add an unsigned 32-bit integer and store the result as an unsigned 32-bit integer. This opcode is as efficient as basic single-precision opcodes since it utilizes the single-precision floating point multiplier. D.u = S0.u[23:0] * S1.u[23:0] + S2.u."
                },
                {
                    "opcode": "324",
                    "name": "V_CUBEID_F32",
                    "short": "Cubemap Face ID determination",
                    "description": "Cubemap Face ID determination.  Result is a floating point face ID. // Set D.f = cubemap face ID ({0.0, 1.0, ..., 5.0}). // XYZ coordinate is given in (S0.f, S1.f, S2.f). // S0.f = x // S1.f = y // S2.f = z if (abs(S2.f) >= abs(S0.f) && abs(S2.f) >= abs(S1.f)) if (S2.f < 0) D.f = 5.0; else D.f = 4.0; endif; else if (abs(S1.f) >= abs(S0.f)) if (S1.f < 0) D.f = 3.0; else D.f = 2.0; endif; else if (S0.f < 0) D.f = 1.0; else D.f = 0.0; endif; endif."
                },
                {
                    "opcode": "325",
                    "name": "V_CUBESC_F32",
                    "short": "Cubemap S coordinate",
                    "description": "Cubemap S coordinate. // D.f = cubemap S coordinate. // XYZ coordinate is given in (S0.f, S1.f, S2.f). // S0.f = x // S1.f = y // S2.f = z if (abs(S2.f) >= abs(S0.f) && abs(S2.f) >= abs(S1.f)) if (S2.f < 0) D.f = -S0.f; else D.f = S0.f; endif; else if (abs(S1.f) >= abs(S0.f)) D.f = S0.f; else if (S0.f < 0) D.f = S2.f; else D.f = -S2.f; endif; endif."
                },
                {
                    "opcode": "326",
                    "name": "V_CUBETC_F32",
                    "short": "Cubemap T coordinate",
                    "description": "Cubemap T coordinate. // D.f = cubemap T coordinate. // XYZ coordinate is given in (S0.f, S1.f, S2.f). // S0.f = x // S1.f = y // S2.f = z if (abs(S2.f) >= abs(S0.f) && abs(S2.f) >= bs(S1.f)) D.f = -S1.f; else if (abs(S1.f) >= abs(S0.f)) if (S1.f < 0) D.f = -S2.f; else D.f = S2.f; endif; else D.f = -S1.f; endif."
                },
                {
                    "opcode": "327",
                    "name": "V_CUBEMA_F32",
                    "short": "Determine cubemap major axis",
                    "description": "Determine cubemap major axis. // D.f = 2.0 * cubemap major axis. // XYZ coordinate is given in (S0.f, S1.f, S2.f). // S0.f = x // S1.f = y // S2.f = z if (abs(S2.f) >= abs(S0.f) && abs(S2.f) >= abs(S1.f)) D.f = 2.0 * S2.f; else if (abs(S1.f) >= abs(S0.f)) D.f = 2.0 * S1.f; else D.f = 2.0 * S0.f; endif."
                },
                {
                    "opcode": "328",
                    "name": "V_BFE_U32",
                    "short": "Bitfield extract with S0 = data, S1 = field_offset, S2 = field_width",
                    "description": "Bitfield extract with S0 = data, S1 = field_offset, S2 = field_width. D.u = (S0.u >> S1.u[4:0]) & ((1 << S2.u[4:0]) - 1)."
                },
                {
                    "opcode": "329",
                    "name": "V_BFE_I32",
                    "short": "Bitfield extract with S0 = data, S1 = field_offset, S2 = field_width",
                    "description": "Bitfield extract with S0 = data, S1 = field_offset, S2 = field_width. D.i = (S0.i >> S1.u[4:0]) & ((1 << S2.u[4:0]) - 1)."
                },
                {
                    "opcode": "330",
                    "name": "V_BFI_B32",
                    "short": "Bitfield insert",
                    "description": "Bitfield insert. D.u = (S0.u & S1.u) | (~S0.u & S2.u)."
                },
                {
                    "opcode": "331",
                    "name": "V_FMA_F32",
                    "short": "Fused single precision multiply add",
                    "description": "Fused single precision multiply add.  0.5ULP accuracy, denormals are supported. D.f = S0.f * S1.f + S2.f."
                },
                {
                    "opcode": "332",
                    "name": "V_FMA_F64",
                    "short": "Fused double precision multiply add",
                    "description": "Fused double precision multiply add.  0.5ULP precision, denormals are supported. D.d = S0.d * S1.d + S2.d."
                },
                {
                    "opcode": "333",
                    "name": "V_LERP_U8",
                    "short": "Unsigned 8-bit pixel average on packed unsigned bytes (linear interpolation)",
                    "description": "Unsigned 8-bit pixel average on packed unsigned bytes (linear interpolation).  S2 acts as a round mode; if set, 0.5 rounds up, otherwise 0.5 truncates. D.u = ((S0.u[31:24] + S1.u[31:24] + S2.u[24]) >> 1) << 24 D.u += ((S0.u[23:16] + S1.u[23:16] + S2.u[16]) >> 1) << 16; D.u += ((S0.u[15:8] + S1.u[15:8] + S2.u[8]) >> 1) << 8; D.u += ((S0.u[7:0] + S1.u[7:0] + S2.u[0]) >> 1)."
                },
                {
                    "opcode": "334",
                    "name": "V_ALIGNBIT_B32",
                    "short": "Align a value to the specified bit position",
                    "description": "Align a value to the specified bit position. D.u = ({S0,S1} >> S2.u[4:0]) & 0xffffffff."
                },
                {
                    "opcode": "335",
                    "name": "V_ALIGNBYTE_B32",
                    "short": "Align a value to the specified byte position",
                    "description": "Align a value to the specified byte position. D.u = ({S0,S1} >> (8*S2.u[4:0])) & 0xffffffff."
                },
                {
                    "opcode": "336",
                    "name": "V_MULLIT_F32",
                    "short": "Multiply for lighting",
                    "description": "Multiply for lighting.  Specific rules apply: 0.0 * x = 0.0; Specific INF, NaN, overflow rules. D.f = S0.f * S1.f"
                },
                {
                    "opcode": "337",
                    "name": "V_MIN3_F32",
                    "short": "Return minimum single-precision value of three inputs",
                    "description": "Return minimum single-precision value of three inputs. D.f = V_MIN_F32(V_MIN_F32(S0.f, S1.f), S2.f)."
                },
                {
                    "opcode": "338",
                    "name": "V_MIN3_I32",
                    "short": "Return minimum signed integer value of three inputs",
                    "description": "Return minimum signed integer value of three inputs. D.i = V_MIN_I32(V_MIN_I32(S0.i, S1.i), S2.i)."
                },
                {
                    "opcode": "339",
                    "name": "V_MIN3_U32",
                    "short": "Return minimum unsigned integer value of three inputs",
                    "description": "Return minimum unsigned integer value of three inputs. D.u = V_MIN_U32(V_MIN_U32(S0.u, S1.u), S2.u)."
                },
                {
                    "opcode": "340",
                    "name": "V_MAX3_F32",
                    "short": "Return maximum single precision value of three inputs",
                    "description": "Return maximum single precision value of three inputs. D.f = V_MAX_F32(V_MAX_F32(S0.f, S1.f), S2.f)."
                },
                {
                    "opcode": "341",
                    "name": "V_MAX3_I32",
                    "short": "Return maximum signed integer value of three inputs",
                    "description": "Return maximum signed integer value of three inputs. D.i = V_MAX_I32(V_MAX_I32(S0.i, S1.i), S2.i)."
                },
                {
                    "opcode": "342",
                    "name": "V_MAX3_U32",
                    "short": "Return maximum unsigned integer value of three inputs",
                    "description": "Return maximum unsigned integer value of three inputs. D.u = V_MAX_U32(V_MAX_U32(S0.u, S1.u), S2.u)."
                },
                {
                    "opcode": "343",
                    "name": "V_MED3_F32",
                    "short": "Return median single precision value of three inputs",
                    "description": "Return median single precision value of three inputs. if (isNan(S0.f) || isNan(S1.f) || isNan(S2.f)) D.f = V_MIN3_F32(S0.f, S1.f, S2.f); else if (V_MAX3_F32(S0.f, S1.f, S2.f) == S0.f) D.f = V_MAX_F32(S1.f, S2.f); else if (V_MAX3_F32(S0.f, S1.f, S2.f) == S1.f) D.f = V_MAX_F32(S0.f, S2.f); else D.f = V_MAX_F32(S0.f, S1.f); endif."
                },
                {
                    "opcode": "344",
                    "name": "V_MED3_I32",
                    "short": "Return median signed integer value of three inputs",
                    "description": "Return median signed integer value of three inputs. if (V_MAX3_I32(S0.i, S1.i, S2.i) == S0.i) D.i = V_MAX_I32(S1.i, S2.i); else if (V_MAX3_I32(S0.i, S1.i, S2.i) == S1.i) D.i = V_MAX_I32(S0.i, S2.i); else D.i = V_MAX_I32(S0.i, S1.i); endif."
                },
                {
                    "opcode": "345",
                    "name": "V_MED3_U32",
                    "short": "Return median unsigned integer value of three inputs",
                    "description": "Return median unsigned integer value of three inputs. if (V_MAX3_U32(S0.u, S1.u, S2.u) == S0.u) D.u = V_MAX_U32(S1.u, S2.u); else if (V_MAX3_U32(S0.u, S1.u, S2.u) == S1.u) D.u = V_MAX_U32(S0.u, S2.u); else D.u = V_MAX_U32(S0.u, S1.u); endif."
                },
                {
                    "opcode": "346",
                    "name": "V_SAD_U8",
                    "short": "Sum of absolute differences with accumulation, overflow into upper bits is allowed",
                    "description": "Sum of absolute differences with accumulation, overflow into upper bits is allowed. ABSDIFF(x, y) := (x > y ? x - y : y - x) // UNSIGNED comparison D.u  = S2.u; D.u += ABSDIFF(S0.u[31:24], S1.u[31:24]); D.u += ABSDIFF(S0.u[23:16], S1.u[23:16]); D.u += ABSDIFF(S0.u[15:8],  S1.u[15:8]); D.u += ABSDIFF(S0.u[7:0],S1.u[7:0])."
                },
                {
                    "opcode": "347",
                    "name": "V_SAD_HI_U8",
                    "short": "Sum of absolute differences with accumulation, accumulate into the higher-order bits of S2",
                    "description": "Sum of absolute differences with accumulation, accumulate into the higher-order bits of S2. D.u = (V_SAD_U8(S0, S1, 0) << 16) + S2.u."
                },
                {
                    "opcode": "348",
                    "name": "V_SAD_U16",
                    "short": "Short SAD with accumulation",
                    "description": "Short SAD with accumulation. ABSDIFF(x, y) := (x > y ? x - y : y - x) // UNSIGNED comparison D.u  = S2.u; D.u += ABSDIFF(S0.u[31:16], S1.u[31:16]); D.u += ABSDIFF(S0.u[15:0],  S1.u[15:0])."
                },
                {
                    "opcode": "349",
                    "name": "V_SAD_U32",
                    "short": "Dword SAD with accumulation",
                    "description": "Dword SAD with accumulation. ABSDIFF(x, y) := (x > y ? x - y : y - x) // UNSIGNED comparison D.u = ABSDIFF(S0.u, S1.u) + S2.u."
                },
                {
                    "opcode": "350",
                    "name": "V_CVT_PK_U8_F32",
                    "short": "Convert floating point value S0 to 8-bit unsigned integer and pack the result into byte S1 of dword S2",
                    "description": "Convert floating point value S0 to 8-bit unsigned integer and pack the result into byte S1 of dword S2. D.u = (S2.u & ~(0xff << (8 * S1.u[1:0]))); D.u = D.u | ((flt32_to_uint8(S0.f) & 0xff) << (8 * S1.u[1:0]))."
                },
                {
                    "opcode": "352",
                    "name": "V_DIV_FIXUP_F64",
                    "short": "Double precision division fixup",
                    "description": "Double precision division fixup. S0 = Quotient, S1 = Denominator, S2 = Numerator. Given a numerator, denominator, and quotient from a divide, this opcode will detect and apply specific case numerics, touching up the quotient if necessary. This opcode also generates invalid, denorm and divide by zero exceptions caused by the division. sign_out =  sign(S1.d)^sign(S2.d); if (S2.d == NAN) D.d = Quiet(S2.d); else if (S1.d == NAN) D.d = Quiet(S1.d); else if (S1.d == S2.d == 0) // 0/0 D.d = 0xfff8_0000_0000_0000; else if (abs(S1.d) == abs(S2.d) == +-INF) // inf/inf D.d = 0xfff8_0000_0000_0000; else if (S1.d == 0 || abs(S2.d) == +-INF) // x/0, or inf/y D.d = sign_out ? -INF : +INF; else if (abs(S1.d) == +-INF || S2.d == 0) // x/inf, 0/y D.d = sign_out ? -0 : 0; else if ((exponent(S2.d) - exponent(S1.d)) < -1075) D.d = sign_out ? -underflow : underflow; else if (exponent(S1.d) == 2047) D.d = sign_out ? -overflow : overflow; else D.d = sign_out ? -abs(S0.d) : abs(S0.d); endif."
                },
                {
                    "opcode": "356",
                    "name": "V_ADD_F64",
                    "short": "Add two double-precision values",
                    "description": "Add two double-precision values.  0.5ULP precision, denormals are supported. D.d = S0.d + S1.d."
                },
                {
                    "opcode": "357",
                    "name": "V_MUL_F64",
                    "short": "Multiply two double-precision values",
                    "description": "Multiply two double-precision values.  0.5ULP precision, denormals are supported. D.d = S0.d * S1.d."
                },
                {
                    "opcode": "358",
                    "name": "V_MIN_F64",
                    "short": "Compute the minimum of two double-precision floats",
                    "description": "Compute the minimum of two double-precision floats. if (IEEE_MODE && S0.d == sNaN) D.d = Quiet(S0.d); else if (IEEE_MODE && S1.d == sNaN) D.d = Quiet(S1.d); else if (S0.d == NaN) D.d = S1.d; else if (S1.d == NaN) D.d = S0.d; else if (S0.d == +0.0 && S1.d == -0.0) D.d = S1.d; else if (S0.d == -0.0 && S1.d == +0.0) D.d = S0.d; else // Note: there's no IEEE special case here like there is for V_MAX_F64. D.d = (S0.d < S1.d ? S0.d : S1.d); endif."
                },
                {
                    "opcode": "359",
                    "name": "V_MAX_F64",
                    "short": "Compute the maximum of two double-precision floats",
                    "description": "Compute the maximum of two double-precision floats. if (IEEE_MODE && S0.d == sNaN) D.d = Quiet(S0.d); else if (IEEE_MODE && S1.d == sNaN) D.d = Quiet(S1.d); else if (S0.d == NaN) D.d = S1.d; else if (S1.d == NaN) D.d = S0.d; else if (S0.d == +0.0 && S1.d == -0.0) D.d = S0.d; else if (S0.d == -0.0 && S1.d == +0.0) D.d = S1.d; else if (IEEE_MODE) D.d = (S0.d >= S1.d ? S0.d : S1.d); else D.d = (S0.d > S1.d ? S0.d : S1.d); endif."
                },
                {
                    "opcode": "360",
                    "name": "V_LDEXP_F64",
                    "short": "Multiply a double-precision float by an integral power of 2, compare with the ldexp() function in C",
                    "description": "Multiply a double-precision float by an integral power of 2, compare with the ldexp() function in C. D.d = S0.d * (2 ** S1.i)."
                },
                {
                    "opcode": "361",
                    "name": "V_MUL_LO_U32",
                    "short": "Multiply two unsigned integers",
                    "description": "Multiply two unsigned integers.  If you only need to multiply integers with small magnitudes consider V_MUL_U32_U24, which is a faster implementation. D.u = S0.u * S1.u."
                },
                {
                    "opcode": "362",
                    "name": "V_MUL_HI_U32",
                    "short": "Multiply two unsigned integers and store the high 32 bits of the result",
                    "description": "Multiply two unsigned integers and store the high 32 bits of the result.  If you only need to multiply integers with small magnitudes consider V_MUL_HI_U32_U24, which is a faster implementation. D.u = (S0.u * S1.u) >> 32."
                },
                {
                    "opcode": "364",
                    "name": "V_MUL_HI_I32",
                    "short": "Multiply two signed integers and store the high 32 bits of the result",
                    "description": "Multiply two signed integers and store the high 32 bits of the result.  If you only need to multiply integers with small magnitudes consider V_MUL_HI_I32_I24, which is a faster implementation. D.i = (S0.i * S1.i) >> 32."
                },
                {
                    "opcode": "365",
                    "name": "V_DIV_SCALE_F32",
                    "short": "Single precision division pre-scale",
                    "description": "Single precision division pre-scale.  S0 = Input to scale (either denominator or numerator), S1 = Denominator, S2 = Numerator. Given a numerator and denominator, this opcode will appropriately scale inputs for division to avoid subnormal terms during Newton-Raphson correction algorithm.  S0 must be the same value as either S1 or S2. This opcode producses a VCC flag for post-scaling of the quotient (using V_DIV_FMAS_F32). VCC = 0; if (S2.f == 0 || S1.f == 0) D.f = NAN else if (exponent(S2.f) - exponent(S1.f) >= 96) // N/D near MAX_FLOAT VCC = 1; if (S0.f == S1.f) // Only scale the denominator D.f = ldexp(S0.f, 64); end if else if (S1.f == DENORM) D.f = ldexp(S0.f, 64); else if (1 / S1.f == DENORM && S2.f / S1.f == DENORM) VCC = 1; if (S0.f == S1.f) // Only scale the denominator D.f = ldexp(S0.f, 64); end if else if (1 / S1.f == DENORM) D.f = ldexp(S0.f, -64); else if (S2.f / S1.f==DENORM) VCC = 1; if (S0.f == S2.f) // Only scale the numerator D.f = ldexp(S0.f, 64); end if else if (exponent(S2.f) <= 23) // Numerator is tiny D.f = ldexp(S0.f, 64); end if."
                },
                {
                    "opcode": "366",
                    "name": "V_DIV_SCALE_F64",
                    "short": "Double precision division pre-scale",
                    "description": "Double precision division pre-scale.  S0 = Input to scale (either denominator or numerator), S1 = Denominator, S2 = Numerator. Given a numerator and denominator, this opcode will appropriately scale inputs for division to avoid subnormal terms during Newton-Raphson correction algorithm.  S0 must be the same value as either S1 or S2. This opcode producses a VCC flag for post-scaling of the quotient (using V_DIV_FMAS_F64). VCC = 0; if (S2.d == 0 || S1.d == 0) D.d = NAN else if (exponent(S2.d) - exponent(S1.d) >= 768) // N/D near MAX_FLOAT VCC = 1; if (S0.d == S1.d) // Only scale the denominator D.d = ldexp(S0.d, 128); end if else if (S1.d == DENORM) D.d = ldexp(S0.d, 128); else if (1 / S1.d == DENORM && S2.d / S1.d == DENORM) VCC = 1; if (S0.d == S1.d) // Only scale the denominator D.d = ldexp(S0.d, 128); end if else if (1 / S1.d == DENORM) D.d = ldexp(S0.d, -128); else if (S2.d / S1.d==DENORM) VCC = 1; if (S0.d == S2.d) // Only scale the numerator D.d = ldexp(S0.d, 128); end if else if (exponent(S2.d) <= 53) // Numerator is tiny D.d = ldexp(S0.d, 128); end if."
                },
                {
                    "opcode": "367",
                    "name": "V_DIV_FMAS_F32",
                    "short": "Single precision FMA with fused scale",
                    "description": "Single precision FMA with fused scale. This opcode performs a standard Fused Multiply-Add operation and will conditionally scale the resulting exponent if VCC is set. Input denormals are not flushed, but output flushing is allowed. if (VCC[threadId]) D.f = 2**32 * (S0.f * S1.f + S2.f); else D.f = S0.f * S1.f + S2.f; end if."
                },
                {
                    "opcode": "368",
                    "name": "V_DIV_FMAS_F64",
                    "short": "Double precision FMA with fused scale",
                    "description": "Double precision FMA with fused scale. This opcode performs a standard Fused Multiply-Add operation and will conditionally scale the resulting exponent if VCC is set. Input denormals are not flushed, but output flushing is allowed. if (VCC[threadId]) D.d = 2**64 * (S0.d * S1.d + S2.d); else D.d = S0.d * S1.d + S2.d; end if."
                },
                {
                    "opcode": "369",
                    "name": "V_MSAD_U8",
                    "short": "Masked sum of absolute differences with accumulation, overflow into upper bits is allowed",
                    "description": "Masked sum of absolute differences with accumulation, overflow into upper bits is allowed.  Components where the reference value in S1 is zero are not included in the sum. ABSDIFF(x, y) := (x > y ? x - y : y - x) // UNSIGNED comparison D.u  = S2.u; D.u += S1.u[31:24] == 0 ? 0 : ABSDIFF(S0.u[31:24], S1.u[31:24]); D.u += S1.u[23:16] == 0 ? 0 : ABSDIFF(S0.u[23:16], S1.u[23:16]); D.u += S1.u[15:8]  == 0 ? 0 : ABSDIFF(S0.u[15:8],  S1.u[15:8]); D.u += S1.u[7:0]== 0 ? 0 : ABSDIFF(S0.u[7:0],S1.u[7:0])."
                },
                {
                    "opcode": "370",
                    "name": "V_QSAD_PK_U16_U8",
                    "short": "Quad-byte SAD with 16-bit packed accumulation",
                    "description": "Quad-byte SAD with 16-bit packed accumulation. D[63:48] = SAD_U8(S0[55:24], S1[31:0], S2[63:48]); D[47:32] = SAD_U8(S0[47:16], S1[31:0], S2[47:32]); D[31:16] = SAD_U8(S0[39:8],  S1[31:0], S2[31:16]); D[15:0]  = SAD_U8(S0[31:0],  S1[31:0], S2[15:0])."
                },
                {
                    "opcode": "371",
                    "name": "V_MQSAD_PK_U16_U8",
                    "short": "Quad-byte masked SAD with 16-bit packed accumulation",
                    "description": "Quad-byte masked SAD with 16-bit packed accumulation. D[63:48] = MSAD_U8(S0[55:24], S1[31:0], S2[63:48]); D[47:32] = MSAD_U8(S0[47:16], S1[31:0], S2[47:32]); D[31:16] = MSAD_U8(S0[39:8],  S1[31:0], S2[31:16]); D[15:0]  = MSAD_U8(S0[31:0],  S1[31:0], S2[15:0])."
                },
                {
                    "opcode": "372",
                    "name": "V_TRIG_PREOP_F64",
                    "short": "Look Up 2/PI (S0",
                    "description": "Look Up 2/PI (S0.d) with segment select S1.u[4:0].  This operation returns an aligned, double precision segment of 2/PI needed to do range reduction on S0.d (double-precision value). Multiple segments can be specified through S1.u[4:0].  Rounding is round-to-zero.  Large inputs (exp > 1968) are scaled to avoid loss of precision through denormalization. shift = S1.u * 53; if exponent(S0.d) > 1077 then shift += exponent(S0.d) - 1077; endif result = (double) ((2/PI[1200:0] << shift) & 0x1fffff_ffffffff); scale = (-53 - shift); if exponent(S0.d) >= 1968 then scale += 128; endif D.d = ldexp(result, scale)."
                },
                {
                    "opcode": "373",
                    "name": "V_MQSAD_U32_U8",
                    "short": "Quad-byte masked SAD with 32-bit packed accumulation",
                    "description": "Quad-byte masked SAD with 32-bit packed accumulation. D[127:96] = MSAD_U8(S0[55:24], S1[31:0], S2[127:96]); D[95:64]  = MSAD_U8(S0[47:16], S1[31:0], S2[95:64]); D[63:32]  = MSAD_U8(S0[39:8],  S1[31:0], S2[63:32]); D[31:0]= MSAD_U8(S0[31:0],  S1[31:0], S2[31:0])."
                },
                {
                    "opcode": "374",
                    "name": "V_MAD_U64_U32",
                    "short": "Multiply and add unsigned integers and produce a 64-bit result",
                    "description": "Multiply and add unsigned integers and produce a 64-bit result. {vcc_out,D.u64} = S0.u32 * S1.u32 + S2.u64."
                },
                {
                    "opcode": "375",
                    "name": "V_MAD_I64_I32",
                    "short": "Multiply and add signed integers and produce a 64-bit result",
                    "description": "Multiply and add signed integers and produce a 64-bit result. {vcc_out,D.i64} = S0.i32 * S1.i32 + S2.i64."
                },
                {
                    "opcode": "376",
                    "name": "V_XOR3_B32",
                    "short": "Bitwise XOR of three inputs",
                    "description": "Bitwise XOR of three inputs.  Input and output modifiers not supported. D.u32 = S0.u32 ^ S1.u32 ^ S2.u32."
                },
                {
                    "opcode": "767",
                    "name": "V_LSHLREV_B64",
                    "short": "Logical shift left, count is in the first operand",
                    "description": "Logical shift left, count is in the first operand.  Only one scalar broadcast constant is allowed. D.u64 = S1.u64 << S0.u[5:0]."
                },
                {
                    "opcode": "768",
                    "name": "V_LSHRREV_B64",
                    "short": "Logical shift right, count is in the first operand",
                    "description": "Logical shift right, count is in the first operand.  Only one scalar broadcast constant is allowed. D.u64 = S1.u64 >> S0.u[5:0]."
                },
                {
                    "opcode": "769",
                    "name": "V_ASHRREV_I64",
                    "short": "Arithmetic shift right (preserve sign bit), count is in the first operand",
                    "description": "Arithmetic shift right (preserve sign bit), count is in the first operand.  Only one scalar broadcast constant is allowed. D.u64 = signext(S1.u64) >> S0.u[5:0]."
                },
                {
                    "opcode": "771",
                    "name": "V_ADD_NC_U16",
                    "short": "Add two unsigned shorts",
                    "description": "Add two unsigned shorts.  Supports saturation (unsigned 16-bit integer domain).  No carry-in or carry-out. D.u16 = S0.u16 + S1.u16."
                },
                {
                    "opcode": "772",
                    "name": "V_SUB_NC_U16",
                    "short": "Subtract the second unsigned short from the first",
                    "description": "Subtract the second unsigned short from the first.  Supports saturation (unsigned 16-bit integer domain).  No carry-in or carry-out. D.u16 = S0.u16 - S1.u16."
                },
                {
                    "opcode": "773",
                    "name": "V_MUL_LO_U16",
                    "short": "Multiply two unsigned shorts",
                    "description": "Multiply two unsigned shorts.  Supports saturation (unsigned 16-bit integer domain). D.u16 = S0.u16 * S1.u16."
                },
                {
                    "opcode": "775",
                    "name": "V_LSHRREV_B16",
                    "short": "Logical shift right, count is in the first operand",
                    "description": "Logical shift right, count is in the first operand. D.u[15:0] = S1.u[15:0] >> S0.u[3:0]."
                },
                {
                    "opcode": "776",
                    "name": "V_ASHRREV_I16",
                    "short": "Arithmetic shift right (preserve sign bit), count is in the first operand",
                    "description": "Arithmetic shift right (preserve sign bit), count is in the first operand. D.i[15:0] = signext(S1.i[15:0]) >> S0.i[3:0]."
                },
                {
                    "opcode": "777",
                    "name": "V_MAX_U16",
                    "short": "Maximum of two unsigned shorts",
                    "description": "Maximum of two unsigned shorts. D.u16 = (S0.u16 >= S1.u16 ? S0.u16 : S1.u16)."
                },
                {
                    "opcode": "778",
                    "name": "V_MAX_I16",
                    "short": "Maximum of two signed shorts",
                    "description": "Maximum of two signed shorts. D.i16 = (S0.i16 >= S1.i16 ? S0.i16 : S1.i16)."
                },
                {
                    "opcode": "779",
                    "name": "V_MIN_U16",
                    "short": "Minimum of two unsigned shorts",
                    "description": "Minimum of two unsigned shorts. D.u16 = (S0.u16 < S1.u16 ? S0.u16 : S1.u16)."
                },
                {
                    "opcode": "780",
                    "name": "V_MIN_I16",
                    "short": "Minimum of two signed shorts",
                    "description": "Minimum of two signed shorts. D.i16 = (S0.i16 < S1.i16 ? S0.i16 : S1.i16)."
                },
                {
                    "opcode": "781",
                    "name": "V_ADD_NC_I16",
                    "short": "Add two signed shorts",
                    "description": "Add two signed shorts.  Supports saturation (signed 16-bit integer domain).  No carry-in or carry-out. D.i16 = S0.i16 + S1.i16."
                },
                {
                    "opcode": "782",
                    "name": "V_SUB_NC_I16",
                    "short": "Subtract the second signed short from the first",
                    "description": "Subtract the second signed short from the first.  Supports saturation (unsigned 16-bit integer domain).  No carry-in or carry-out. D.i16 = S0.i16 - S1.i16."
                },
                {
                    "opcode": "783",
                    "name": "V_ADD_CO_U32",
                    "short": "Add two unsigned integers with carry-out",
                    "description": "Add two unsigned integers with carry-out.  In VOP3 the VCC destination may be an arbitrary SGPR-pair. D.u32 = S0.u32 + S1.u32; VCC = S0.u + S1.u >= 0x100000000ULL ? 1 : 0."
                },
                {
                    "opcode": "784",
                    "name": "V_SUB_CO_U32",
                    "short": "Subtract the second unsigned integer from the first with carry-out",
                    "description": "Subtract the second unsigned integer from the first with carry-out.  In VOP3 the VCC destination may be an arbitrary SGPR-pair. D.u = S0.u - S1.u; VCC[threadId] = (S1.u > S0.u ? 1 : 0). // VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32."
                },
                {
                    "opcode": "785",
                    "name": "V_PACK_B32_F16",
                    "short": "Pack two FP16 values together",
                    "description": "Pack two FP16 values together. D[31:16].f16 = S1.f16; D[15:0].f16 = S0.f16."
                },
                {
                    "opcode": "786",
                    "name": "V_CVT_PKNORM_I16_F16",
                    "short": "Convert two FP16 values into packed signed normalized shorts",
                    "description": "Convert two FP16 values into packed signed normalized shorts. D = {(snorm)S1.f16, (snorm)S0.f16}."
                },
                {
                    "opcode": "787",
                    "name": "V_CVT_PKNORM_U16_F16",
                    "short": "Convert two FP16 values into packed unsigned normalized shorts",
                    "description": "Convert two FP16 values into packed unsigned normalized shorts. D = {(unorm)S1.f16, (unorm)S0.f16}."
                },
                {
                    "opcode": "788",
                    "name": "V_LSHLREV_B16",
                    "short": "Logical shift left, count is in the first operand",
                    "description": "Logical shift left, count is in the first operand. D.u[15:0] = S1.u[15:0] << S0.u[3:0]."
                },
                {
                    "opcode": "793",
                    "name": "V_SUBREV_CO_U32",
                    "short": "Subtract the first unsigned integer from the second with carry-out",
                    "description": "Subtract the first unsigned integer from the second with carry-out.  In VOP3 the VCC destination may be an arbitrary SGPR-pair. D.u = S1.u - S0.u; VCC[threadId] = (S0.u > S1.u ? 1 : 0). // VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32."
                },
                {
                    "opcode": "832",
                    "name": "V_MAD_U16",
                    "short": "Multiply and add unsigned shorts",
                    "description": "Multiply and add unsigned shorts.  Supports saturation (unsigned 16-bit integer domain). If op_sel[3] is 0: Result is written to 16 LSBs of destination VGPR and hi 16 bits are preserved. If op_sel[3] is 1: Result is written to 16 MSBs of destination VGPR and lo 16 bits are preserved. D.u16 = S0.u16 * S1.u16 + S2.u16."
                },
                {
                    "opcode": "834",
                    "name": "V_INTERP_P1LL_F16",
                    "short": "FP16 parameter interpolation",
                    "description": "FP16 parameter interpolation.  `LL' stands for `two LDS arguments'.  attr_word selects the high or low half 16 bits of each LDS dword accessed.  This opcode is available for 32-bank LDS only. NOTE: In textual representations the I/J VGPR is the first source and the attribute is the second source; however in the VOP3 encoding the attribute is stored in the src0 field and the VGPR is stored in the src1 field. D.f32 = P10.f16 * S0.f32 + P0.f16."
                },
                {
                    "opcode": "835",
                    "name": "V_INTERP_P1LV_F16",
                    "short": "FP16 parameter interpolation",
                    "description": "FP16 parameter interpolation.  `LV' stands for `One LDS and one VGPR argument'.  S2 holds two parameters, attr_word selects the high or low word of the VGPR for this calculation, as well as the high or low half of the LDS data.  Meant for use with 16-bank LDS. NOTE: In textual representations the I/J VGPR is the first source and the attribute is the second source; however in the VOP3 encoding the attribute is stored in the src0 field and the VGPR is stored in the src1 field. D.f32 = P10.f16 * S0.f32 + (S2.u32 >> (attr_word * 16)).f16."
                },
                {
                    "opcode": "836",
                    "name": "V_PERM_B32",
                    "short": "Byte permute",
                    "description": "Byte permute. D.u[31:24] = byte_permute({S0.u, S1.u}, S2.u[31:24]); D.u[23:16] = byte_permute({S0.u, S1.u}, S2.u[23:16]); D.u[15:8] = byte_permute({S0.u, S1.u}, S2.u[15:8]); D.u[7:0] = byte_permute({S0.u, S1.u}, S2.u[7:0]); byte permute(byte in[8], byte sel) { if(sel>=13) then return 0xff; elsif(sel==12) then return 0x00; elsif(sel==11) then return in[7][7] * 0xff; elsif(sel==10) then return in[5][7] * 0xff; elsif(sel==9) then return in[3][7] * 0xff; elsif(sel==8) then return in[1][7] * 0xff; else return in[sel]; }"
                },
                {
                    "opcode": "837",
                    "name": "V_XAD_U32",
                    "short": "Bitwise XOR and then add",
                    "description": "Bitwise XOR and then add.  No carryin/carryout and no saturation.  This opcode exists to accelerate the SHA256 hash algorithm. D.u32 = (S0.u32 ^ S1.u32) + S2.u32."
                },
                {
                    "opcode": "838",
                    "name": "V_LSHL_ADD_U32",
                    "short": "Logical shift left and then add",
                    "description": "Logical shift left and then add. D.u = (S0.u << S1.u[4:0]) + S2.u."
                },
                {
                    "opcode": "839",
                    "name": "V_ADD_LSHL_U32",
                    "short": "Add and then logical shift left the result",
                    "description": "Add and then logical shift left the result. D.u = (S0.u + S1.u) << S2.u[4:0]."
                },
                {
                    "opcode": "843",
                    "name": "V_FMA_F16",
                    "short": "Fused half precision multiply add of FP16 values",
                    "description": "Fused half precision multiply add of FP16 values.  0.5ULP accuracy, denormals are supported. If op_sel[3] is 0 Result is written to 16 LSBs of destination VGPR and hi 16 bits are preserved. If op_sel[3] is 1 Result is written to 16 MSBs of destination VGPR and lo 16 bits are preserved. D.f16 = S0.f16 * S1.f16 + S2.f16."
                },
                {
                    "opcode": "849",
                    "name": "V_MIN3_F16",
                    "short": "Return minimum FP16 value of three inputs",
                    "description": "Return minimum FP16 value of three inputs. D.f16 = V_MIN_F16(V_MIN_F16(S0.f16, S1.f16), S2.f16)."
                },
                {
                    "opcode": "850",
                    "name": "V_MIN3_I16",
                    "short": "Return minimum signed short value of three inputs",
                    "description": "Return minimum signed short value of three inputs. D.i16 = V_MIN_I16(V_MIN_I16(S0.i16, S1.i16), S2.i16)."
                },
                {
                    "opcode": "851",
                    "name": "V_MIN3_U16",
                    "short": "Return minimum unsigned short value of three inputs",
                    "description": "Return minimum unsigned short value of three inputs. D.u16 = V_MIN_U16(V_MIN_U16(S0.u16, S1.u16), S2.u16)."
                },
                {
                    "opcode": "852",
                    "name": "V_MAX3_F16",
                    "short": "Return maximum FP16 value of three inputs",
                    "description": "Return maximum FP16 value of three inputs. D.f16 = V_MAX_F16(V_MAX_F16(S0.f16, S1.f16), S2.f16)."
                },
                {
                    "opcode": "853",
                    "name": "V_MAX3_I16",
                    "short": "Return maximum signed short value of three inputs",
                    "description": "Return maximum signed short value of three inputs. D.i16 = V_MAX_I16(V_MAX_I16(S0.i16, S1.i16), S2.i16)."
                },
                {
                    "opcode": "854",
                    "name": "V_MAX3_U16",
                    "short": "Return maximum unsigned short value of three inputs",
                    "description": "Return maximum unsigned short value of three inputs. D.u16 = V_MAX_U16(V_MAX_U16(S0.u16, S1.u16), S2.u16)."
                },
                {
                    "opcode": "855",
                    "name": "V_MED3_F16",
                    "short": "Return median FP16 value of three inputs",
                    "description": "Return median FP16 value of three inputs. if (isNan(S0.f16) || isNan(S1.f16) || isNan(S2.f16)) D.f16 = V_MIN3_F16(S0.f16, S1.f16, S2.f16); else if (V_MAX3_F16(S0.f16, S1.f16, S2.f16) == S0.f16) D.f16 = V_MAX_F16(S1.f16, S2.f16); else if (V_MAX3_F16(S0.f16, S1.f16, S2.f16) == S1.f16) D.f16 = V_MAX_F16(S0.f16, S2.f16); else D.f16 = V_MAX_F16(S0.f16, S1.f16); endif."
                },
                {
                    "opcode": "856",
                    "name": "V_MED3_I16",
                    "short": "Return median signed short value of three inputs",
                    "description": "Return median signed short value of three inputs. if (V_MAX3_I16(S0.i16, S1.i16, S2.i16) == S0.i16) D.i16 = V_MAX_I16(S1.i16, S2.i16); else if (V_MAX3_I16(S0.i16, S1.i16, S2.i16) == S1.i16) D.i16 = V_MAX_I16(S0.i16, S2.i16); else D.i16 = V_MAX_I16(S0.i16, S1.i16); endif."
                },
                {
                    "opcode": "857",
                    "name": "V_MED3_U16",
                    "short": "Return median unsigned short value of three inputs",
                    "description": "Return median unsigned short value of three inputs. if (V_MAX3_U16(S0.u16, S1.u16, S2.u16) == S0.u16) D.u16 = V_MAX_U16(S1.u16, S2.u16); else if (V_MAX3_U16(S0.u16, S1.u16, S2.u16) == S1.u16) D.u16 = V_MAX_U16(S0.u16, S2.u16); else D.u16 = V_MAX_U16(S0.u16, S1.u16); endif."
                },
                {
                    "opcode": "858",
                    "name": "V_INTERP_P2_F16",
                    "short": "FP16 parameter interpolation",
                    "description": "FP16 parameter interpolation.  Final computation.  attr_word selects LDS high or low 16bits.  Used for both 16- and 32-bank LDS. NOTE: In textual representations the I/J VGPR is the first source and the attribute is the second source; however in the VOP3 encoding the attribute is stored in the src0 field and the VGPR is stored in the src1 field. If op_sel[3] is 0 Result is written to 16 LSBs of destination VGPR and hi 16 bits are preserved. If op_sel[3] is 1 Result is written to 16 MSBs of destination VGPR and lo 16 bits are preserved. D.f16 = P20.f16 * S0.f32 + S2.f32."
                },
                {
                    "opcode": "862",
                    "name": "V_MAD_I16",
                    "short": "Multiply and add signed short values",
                    "description": "Multiply and add signed short values.  Supports saturation (signed 16-bit integer domain). If op_sel[3] is 0 Result is written to 16 LSBs of destination VGPR and hi 16 bits are preserved. If op_sel[3] is 1 Result is written to 16 MSBs of destination VGPR and lo 16 bits are preserved. D.i16 = S0.i16 * S1.i16 + S2.i16."
                },
                {
                    "opcode": "863",
                    "name": "V_DIV_FIXUP_F16",
                    "short": "Half precision division fixup",
                    "description": "Half precision division fixup. S0 = Quotient, S1 = Denominator, S2 = Numerator. Given a numerator, denominator, and quotient from a divide, this opcode will detect and apply specific case numerics, touching up the quotient if necessary. This opcode also generates invalid, denorm and divide by zero exceptions caused by the division. If op_sel[3] is 0 Result is written to 16 LSBs of destination VGPR and hi 16 bits are preserved. If op_sel[3] is 1 Result is written to 16 MSBs of destination VGPR and lo 16 bits are preserved. sign_out =  sign(S1.f16)^sign(S2.f16); if (S2.f16 == NAN) D.f16 = Quiet(S2.f16); else if (S1.f16 == NAN) D.f16 = Quiet(S1.f16); else if (S1.f16 == S2.f16 == 0) // 0/0 D.f16 = 0xfe00; else if (abs(S1.f16) == abs(S2.f16) == +-INF) // inf/inf D.f16 = 0xfe00; else if (S1.f16 ==0 || abs(S2.f16) == +-INF) // x/0, or inf/y D.f16 = sign_out ? -INF : +INF; else if (abs(S1.f16) == +-INF || S2.f16 == 0) // x/inf, 0/y D.f16 = sign_out ? -0 : 0; else D.f16 = sign_out ? -abs(S0.f16) : abs(S0.f16); end if."
                },
                {
                    "opcode": "864",
                    "name": "V_READLANE_B32",
                    "short": "Copy one VGPR value to one SGPR",
                    "description": "Copy one VGPR value to one SGPR.  D = SGPR-dest, S0 = Source Data (VGPR# or M0(lds-direct)), S1 = Lane Select (SGPR or M0). Lane is S1 % (32 if wave32, 64 if wave64).  Ignores exec mask. Input and output modifiers not supported; this is an untyped operation. if(wave32) SMEM[D_ADDR] = VMEM[S0_ADDR][S1[4:0]]; // For wave32 else SMEM[D_ADDR] = VMEM[S0_ADDR][S1[5:0]]; // For wave64 endif."
                },
                {
                    "opcode": "865",
                    "name": "V_WRITELANE_B32",
                    "short": "Write value into one VGPR in one lane",
                    "description": "Write value into one VGPR in one lane.  D = VGPR-dest, S0 = Source Data (sgpr, m0, exec or constants), S1 = Lane Select (SGPR or M0).  Lane is S1 % (32 if wave32, 64 if wave64). Ignores exec mask. Input and output modifiers not supported; this is an untyped operation. if(wave32) VMEM[D_ADDR][S1[4:0]] = SMEM[S0_ADDR]; // For wave32 else VMEM[D_ADDR][S1[5:0]] = SMEM[S0_ADDR]; // For wave64 endif."
                },
                {
                    "opcode": "866",
                    "name": "V_LDEXP_F32",
                    "short": "Multiply a single-precision float by an integral power of 2, compare with the ldexp() function in C",
                    "description": "Multiply a single-precision float by an integral power of 2, compare with the ldexp() function in C. D.f = S0.f * (2 ** S1.i)."
                },
                {
                    "opcode": "867",
                    "name": "V_BFM_B32",
                    "short": "Bitfield modify",
                    "description": "Bitfield modify. S0 is the bitfield width and S1 is the bitfield offset. D.u32 = ((1<<S0[4:0])-1) << S1[4:0]."
                },
                {
                    "opcode": "868",
                    "name": "V_BCNT_U32_B32",
                    "short": "Bit count",
                    "description": "Bit count. D.u = S1.u; for i in 0 .. 31 do D.u += S0.u[i]; // count i'th bit endfor."
                },
                {
                    "opcode": "869",
                    "name": "V_MBCNT_LO_U32_B",
                    "short": "Masked bit count, ThreadPosition is the position of this thread 32 in the wavefront (in 0",
                    "description": "Masked bit count, ThreadPosition is the position of this thread 32 in the wavefront (in 0..63).  See also V_MBCNT_HI_U32_B32. ThreadMask = (1LL << ThreadPosition) - 1; MaskedValue = (S0.u & ThreadMask[31:0]); D.u = S1.u; for i in 0 ... 31 do D.u += (MaskedValue[i] == 1 ? 1 : 0); endfor."
                },
                {
                    "opcode": "870",
                    "name": "V_MBCNT_HI_U32_B",
                    "short": "Masked bit count, ThreadPosition is the position of this thread 32 in the wavefront (in 0",
                    "description": "Masked bit count, ThreadPosition is the position of this thread 32 in the wavefront (in 0..63).  See also V_MBCNT_LO_U32_B32.  Note that in Wave32 mode ThreadMask[63:32] == 0 and this instruction simply performs a move from S1 to D. ThreadMask = (1LL << ThreadPosition) - 1; MaskedValue = (S0.u & ThreadMask[63:32]); D.u = S1.u; for i in 0 ... 31 do D.u += (MaskedValue[i] == 1 ? 1 : 0); endfor. Example to compute each thread's position in 0..63: v_mbcnt_lo_u32_b32 v0, -1, 0 v_mbcnt_hi_u32_b32 v0, -1, v0 // v0 now contains ThreadPosition"
                },
                {
                    "opcode": "872",
                    "name": "V_CVT_PKNORM_I16_F32",
                    "short": "Convert two single-precision floats into a packed signed normalized value",
                    "description": "Convert two single-precision floats into a packed signed normalized value. D.i16_lo = (snorm)S0.f32; D.i16_hi = (snorm)S1.f32."
                },
                {
                    "opcode": "873",
                    "name": "V_CVT_PKNORM_U16_F32",
                    "short": "Convert two single-precision floats into a packed unsigned normalized value",
                    "description": "Convert two single-precision floats into a packed unsigned normalized value. D.u16_lo = (unorm)S0.f32; D.u16_hi = (unorm)S1.f32."
                },
                {
                    "opcode": "874",
                    "name": "V_CVT_PK_U16_U32",
                    "short": "Convert two unsigned integers into a packed unsigned short",
                    "description": "Convert two unsigned integers into a packed unsigned short. D.u16_lo = u32_to_u16(S0.u32); D.u16_hi = u32_to_u16(S1.u32)."
                },
                {
                    "opcode": "875",
                    "name": "V_CVT_PK_I16_I32",
                    "short": "Convert two signed integers into a packed signed short",
                    "description": "Convert two signed integers into a packed signed short. D.i16_lo = i32_to_i16(S0.i32); D.i16_hi = i32_to_i16(S1.i32)."
                },
                {
                    "opcode": "877",
                    "name": "V_ADD3_U32",
                    "short": "Add three unsigned integers",
                    "description": "Add three unsigned integers. D.u = S0.u + S1.u + S2.u."
                },
                {
                    "opcode": "879",
                    "name": "V_LSHL_OR_B32",
                    "short": "Logical shift left and then bitwise OR",
                    "description": "Logical shift left and then bitwise OR. D.u = (S0.u << S1.u[4:0]) | S2.u."
                },
                {
                    "opcode": "881",
                    "name": "V_AND_OR_B32",
                    "short": "Bitwise AND and then bitwise OR",
                    "description": "Bitwise AND and then bitwise OR. D.u = (S0.u & S1.u) | S2.u."
                },
                {
                    "opcode": "882",
                    "name": "V_OR3_B32",
                    "short": "Bitwise OR of three inputs",
                    "description": "Bitwise OR of three inputs. D.u = S0.u | S1.u | S2.u."
                },
                {
                    "opcode": "883",
                    "name": "V_MAD_U32_U16",
                    "short": "Multiply and add unsigned values",
                    "description": "Multiply and add unsigned values. D.u32 = S0.u16 * S1.u16 + S2.u32."
                },
                {
                    "opcode": "885",
                    "name": "V_MAD_I32_I16",
                    "short": "Multiply and add signed values",
                    "description": "Multiply and add signed values. D.i32 = S0.i16 * S1.i16 + S2.i32."
                },
                {
                    "opcode": "886",
                    "name": "V_SUB_NC_I32",
                    "short": "Subtract the second signed integer from the first",
                    "description": "Subtract the second signed integer from the first.  No carry-in or carry-out.  Supports saturation (signed 32-bit integer domain). D.i = S0.i - S1.i."
                },
                {
                    "opcode": "888",
                    "name": "V_PERMLANEX16_B3",
                    "short": "Perform arbitrary gather-style operation across two rows (each 2 row is 16 contiguous lanes)",
                    "description": "Perform arbitrary gather-style operation across two rows (each 2 row is 16 contiguous lanes). The first source must be a VGPR and the second and third sources must be scalar values; the second and third source are combined into a single 64-bit value representing lane selects used to swizzle within each row. OP_SEL is not used in its typical manner for this instruction. For this instruction OP_SEL[0] is overloaded to represent the DPP 'FI' (Fetch Inactive) bit and OP_SEL[1] is overloaded to represent the DPP 'BOUND_CTRL' bit. The remainin OP_SEL bits are reserved for this instruction. ABS, NEG and OMOD modifiers should all be zeroed for this instruction. Compare with V_PERMLANE16_B32. lanesel = { S2.u, S1.u }; // Concatenate lane select bits for row in 0 ... 3 do // interval is 0 ... 1 for wave32 mode // Implement arbitrary swizzle across two rows altrow = {row[1], ~row[0]}; // 1<->0, 3<->2 for i in 0 ... 15 do D.lane[row * 16 + i] = S0.lane[altrow * 16 + lanesel[i * 4 + 3:i * 4]]; endfor; endfor. Example implementing a rotation across an entire wave32 wavefront: // Note for this to work, source and destination VGPRs must be different. // For this rotation, lane 15 gets data from lane 16, lane 31 gets data from lane 0. // These are the only two lanes that need to use v_permlanex16_b32. v_mov_b32 exec_lo, 0x7fff7fff; // Lanes getting data from their own row v_mov_b32 s0, 0x87654321; v_mov_b32 s1, 0x0fedcba9; v_permlane16_b32 v1, v0, s0, s1 fi; // FI bit needed for lanes 14 and 30 v_mov_b32 exec_lo, 0x80008000; // Lanes getting data from the other row v_permlanex16_b32 v1, v0, s0, s1 fi; // FI bit needed for lanes 15 and 31"
                },
                {
                    "opcode": "895",
                    "name": "V_ADD_NC_I32",
                    "short": "Add two signed integers",
                    "description": "Add two signed integers.  No carry-in or carry-out.  Supports saturation (signed 32-bit integer domain).  No carry-in or carry-out. D.i = S0.i + S1.i."
                }
            ]
        },
        {
            "key": "lds&gds",
            "name": " LDS & GDS Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "DS_ADD_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "1",
                    "name": "DS_SUB_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "2",
                    "name": "DS_RSUB_U32",
                    "short": "Subtraction with reversed operands",
                    "description": "Subtraction with reversed operands. // 32bit addr = VGPR[ADDR]+{INST1,INST0}; tmp = DS[addr].u32; DS[addr].u32 = VGPR[DATA0].u32-DS[addr].u32; VGPR[VDST].u32 = tmp."
                },
                {
                    "opcode": "3",
                    "name": "DS_INC_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "4",
                    "name": "DS_DEC_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "5",
                    "name": "DS_MIN_I32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "6",
                    "name": "DS_MAX_I32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "7",
                    "name": "DS_MIN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "8",
                    "name": "DS_MAX_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "9",
                    "name": "DS_AND_B32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "10",
                    "name": "DS_OR_B32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "11",
                    "name": "DS_XOR_B32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "12",
                    "name": "DS_MSKOR_B32",
                    "short": "Masked dword OR, D0 contains the mask and D1 contains the new value",
                    "description": "Masked dword OR, D0 contains the mask and D1 contains the new value. // 32bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR] & ~DATA) | DATA2; RETURN_DATA = tmp."
                },
                {
                    "opcode": "13",
                    "name": "DS_WRITE_B32",
                    "short": "Write dword",
                    "description": "Write dword. // 32bit MEM[ADDR] = DATA."
                },
                {
                    "opcode": "14",
                    "name": "DS_WRITE2_B32",
                    "short": "Write 2 dwords",
                    "description": "Write 2 dwords. // 32bit MEM[ADDR + OFFSET0 * 4] = DATA; MEM[ADDR + OFFSET1 * 4] = DATA2."
                },
                {
                    "opcode": "15",
                    "name": "DS_WRITE2ST64_B32",
                    "short": "Write 2 dwords with larger stride",
                    "description": "Write 2 dwords with larger stride. // 32bit MEM[ADDR + OFFSET0 * 4 * 64] = DATA; MEM[ADDR + OFFSET1 * 4 * 64] = DATA2."
                },
                {
                    "opcode": "16",
                    "name": "DS_CMPST_B32",
                    "short": "Compare and store",
                    "description": "Compare and store.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_CMPSWAP opcode. // 32bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "17",
                    "name": "DS_CMPST_F32",
                    "short": "Floating point compare and store that handles NaN/INF/denormal values",
                    "description": "Floating point compare and store that handles NaN/INF/denormal values.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_FCMPSWAP opcode. // 32bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "18",
                    "name": "DS_MIN_F32",
                    "short": "Floating point minimum that handles NaN/INF/denormal values",
                    "description": "Floating point minimum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMIN. // 32bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (cmp < tmp) ? src : tmp."
                },
                {
                    "opcode": "19",
                    "name": "DS_MAX_F32",
                    "short": "Floating point maximum that handles NaN/INF/denormal values",
                    "description": "Floating point maximum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMAX. // 32bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (tmp > cmp) ? src : tmp."
                },
                {
                    "opcode": "20",
                    "name": "DS_NOP",
                    "short": "Do nothing",
                    "description": "Do nothing."
                },
                {
                    "opcode": "21",
                    "name": "DS_ADD_F32",
                    "short": "Floating point add that handles NaN/INF/denormal values",
                    "description": "Floating point add that handles NaN/INF/denormal values. float tmp = MEM[ADDR].f32; MEM[ADDR].f32 += DATA0.f32; VDST.f32 = tmp;"
                },
                {
                    "opcode": "24",
                    "name": "DS_GWS_SEMA_RELEASE_ALL",
                    "short": " GDS Only: The GWS resource (rid) indicated will process this opcode by updating the counter and labeling the specified resource as a semaphore",
                    "description": " GDS Only: The GWS resource (rid) indicated will process this opcode by updating the counter and labeling the specified resource as a semaphore. // Determine the GWS resource to work on rid[5:0] = gds_base[5:0] + offset0[5:0]; // Incr the state counter of the resource state.counter[rid] = state.wave_in_queue; state.type = SEMAPHORE; return rd_done; //release calling wave This action will release ALL queued waves; it Will have no effect if no waves are present."
                },
                {
                    "opcode": "25",
                    "name": "DS_GWS_INIT",
                    "short": "GDS Only: Initialize a barrier or semaphore resource",
                    "description": "GDS Only: Initialize a barrier or semaphore resource. // Determine the GWS resource to work on rid[5:0] = gds_base[5:0] + offset0[5:0]; // Get the value to use in init index = find_first_valid(vector mask) value = DATA[thread: index] // Set the state of the resource state.counter[rid] = lsb(value); //limit #waves state.flag[rid] = 0; return rd_done; //release calling wave"
                },
                {
                    "opcode": "26",
                    "name": "DS_GWS_SEMA_V",
                    "short": "GDS Only: The GWS resource indicated will process this opcode by updating the counter and labeling the resource as a semaphore",
                    "description": "GDS Only: The GWS resource indicated will process this opcode by updating the counter and labeling the resource as a semaphore. //Determine the GWS resource to work on rid[5:0] = gds_base[5:0] + offset0[5:0]; //Incr the state counter of the resource state.counter[rid] += 1; state.type = SEMAPHORE; return rd_done; //release calling wave This action will release one waved if any are queued in this resource."
                },
                {
                    "opcode": "27",
                    "name": "DS_GWS_SEMA_BR",
                    "short": "GDS Only: The GWS resource indicated will process this opcode by updating the counter by the bulk release delivered count and labeling the resource as a semaphore",
                    "description": "GDS Only: The GWS resource indicated will process this opcode by updating the counter by the bulk release delivered count and labeling the resource as a semaphore. //Determine the GWS resource to work on rid[5:0] = gds_base[5:0] + offset0[5:0]; index =  find first valid (vector mask) count = DATA[thread: index]; //Add count to the resource state counter state.counter[rid] += count; state.type = SEMAPHORE; return rd_done; //release calling wave This action will release count number of waves, promptly if queued, or as they arrive from the noted resource."
                },
                {
                    "opcode": "28",
                    "name": "DS_GWS_SEMA_P",
                    "short": "GDS Only: The GWS resource indicated will process this opcode by queueing it until counter enables a release and then decrementing the counter of the resource as a semaphore",
                    "description": "GDS Only: The GWS resource indicated will process this opcode by queueing it until counter enables a release and then decrementing the counter of the resource as a semaphore. //Determine the GWS resource to work on rid[5:0] = gds_base[5:0] + offset0[5:0]; state.type = SEMAPHORE; ENQUEUE until(state[rid].counter > 0) state[rid].counter -= 1; return rd_done;"
                },
                {
                    "opcode": "29",
                    "name": "DS_GWS_BARRIER",
                    "short": "GDS Only: The GWS resource indicated will process this opcode by queueing it until barrier is satisfied",
                    "description": "GDS Only: The GWS resource indicated will process this opcode by queueing it until barrier is satisfied. The number of waves needed is passed in as DATA of first valid thread. //Determine the GWS resource to work on rid[5:0] = gds_base[5:0] + OFFSET0[5:0]; index =  find first valid (vector mask); value = DATA[thread: index]; // Input Decision Machine state.type[rid] = BARRIER; if(state[rid].counter <= 0) then thread[rid].flag = state[rid].flag; ENQUEUE; state[rid].flag = !state.flag; state[rid].counter = value; return rd_done; else state[rid].counter -= 1; thread.flag = state[rid].flag; ENQUEUE; endif. Since the waves deliver the count for the next barrier, this function can have a different size barrier for each occurrence. // Release Machine if(state.type == BARRIER) then if(state.flag != thread.flag) then return rd_done; endif; endif."
                },
                {
                    "opcode": "30",
                    "name": "DS_WRITE_B8",
                    "short": "Byte write",
                    "description": "Byte write. MEM[ADDR] = DATA[7:0]."
                },
                {
                    "opcode": "31",
                    "name": "DS_WRITE_B16",
                    "short": "Short write",
                    "description": "Short write. MEM[ADDR] = DATA[15:0]."
                },
                {
                    "opcode": "32",
                    "name": "DS_ADD_RTN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "33",
                    "name": "DS_SUB_RTN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "34",
                    "name": "DS_RSUB_RTN_U32",
                    "short": "Subtraction with reversed operands",
                    "description": "Subtraction with reversed operands. // 32bit addr = VGPR[ADDR]+{INST1,INST0}; tmp = DS[addr].u32; DS[addr].u32 = VGPR[DATA0].u32-DS[addr].u32; VGPR[VDST].u32 = tmp."
                },
                {
                    "opcode": "35",
                    "name": "DS_INC_RTN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "36",
                    "name": "DS_DEC_RTN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "37",
                    "name": "DS_MIN_RTN_I32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "38",
                    "name": "DS_MAX_RTN_I32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "39",
                    "name": "DS_MIN_RTN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "40",
                    "name": "DS_MAX_RTN_U32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "41",
                    "name": "DS_AND_RTN_B32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "42",
                    "name": "DS_OR_RTN_B32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "43",
                    "name": "DS_XOR_RTN_B32",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "44",
                    "name": "DS_MSKOR_RTN_B32",
                    "short": "Masked dword OR, D0 contains the mask and D1 contains the new value",
                    "description": "Masked dword OR, D0 contains the mask and D1 contains the new value. // 32bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR] & ~DATA) | DATA2; RETURN_DATA = tmp."
                },
                {
                    "opcode": "45",
                    "name": "DS_WRXCHG_RTN_B32",
                    "short": "Write-exchange operation",
                    "description": "Write-exchange operation. tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "46",
                    "name": "DS_WRXCHG2_RTN_B32",
                    "short": " Write-exchange 2 separate dwords",
                    "description": " Write-exchange 2 separate dwords."
                },
                {
                    "opcode": "47",
                    "name": "DS_WRXCHG2ST64_RTN_B32",
                    "short": " Write-exchange 2 separate dwords with a stride of 64 dwords",
                    "description": " Write-exchange 2 separate dwords with a stride of 64 dwords."
                },
                {
                    "opcode": "48",
                    "name": "DS_CMPST_RTN_B32",
                    "short": "Compare and store",
                    "description": "Compare and store.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_CMPSWAP opcode. // 32bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "49",
                    "name": "DS_CMPST_RTN_F32",
                    "short": "Floating point compare and store that handles NaN/INF/denormal values",
                    "description": "Floating point compare and store that handles NaN/INF/denormal values.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_FCMPSWAP opcode. // 32bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "50",
                    "name": "DS_MIN_RTN_F32",
                    "short": "Floating point minimum that handles NaN/INF/denormal values",
                    "description": "Floating point minimum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMIN. // 32bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (cmp < tmp) ? src : tmp."
                },
                {
                    "opcode": "51",
                    "name": "DS_MAX_RTN_F32",
                    "short": "Floating point maximum that handles NaN/INF/denormal values",
                    "description": "Floating point maximum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMAX. // 32bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (tmp > cmp) ? src : tmp."
                },
                {
                    "opcode": "52",
                    "name": "DS_WRAP_RTN_B32",
                    "short": "tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? tmp - DATA : tmp + DATA2; RETURN_DATA = tmp",
                    "description": "tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? tmp - DATA : tmp + DATA2; RETURN_DATA = tmp."
                },
                {
                    "opcode": "53",
                    "name": "DS_SWIZZLE_B32",
                    "short": "Dword swizzle, no data is written to LDS memory",
                    "description": "Dword swizzle, no data is written to LDS memory. See next section for details."
                },
                {
                    "opcode": "54",
                    "name": "DS_READ_B32",
                    "short": "Dword read",
                    "description": "Dword read. RETURN_DATA = MEM[ADDR]."
                },
                {
                    "opcode": "55",
                    "name": "DS_READ2_B32",
                    "short": "Read 2 dwords",
                    "description": "Read 2 dwords. RETURN_DATA[0] = MEM[ADDR + OFFSET0 * 4]; RETURN_DATA[1] = MEM[ADDR + OFFSET1 * 4]."
                },
                {
                    "opcode": "56",
                    "name": "DS_READ2ST64_B32",
                    "short": "Read 2 dwords with a larger stride",
                    "description": "Read 2 dwords with a larger stride. RETURN_DATA[0] = MEM[ADDR + OFFSET0 * 4 * 64]; RETURN_DATA[1] = MEM[ADDR + OFFSET1 * 4 * 64]."
                },
                {
                    "opcode": "57",
                    "name": "DS_READ_I8",
                    "short": "Signed byte read",
                    "description": "Signed byte read. RETURN_DATA = signext(MEM[ADDR][7:0])."
                },
                {
                    "opcode": "58",
                    "name": "DS_READ_U8",
                    "short": "Unsigned byte read",
                    "description": "Unsigned byte read. RETURN_DATA = {24'h0,MEM[ADDR][7:0]}."
                },
                {
                    "opcode": "59",
                    "name": "DS_READ_I16",
                    "short": "Signed short read",
                    "description": "Signed short read. RETURN_DATA = signext(MEM[ADDR][15:0])."
                },
                {
                    "opcode": "60",
                    "name": "DS_READ_U16",
                    "short": "Unsigned short read",
                    "description": "Unsigned short read. RETURN_DATA = {16'h0,MEM[ADDR][15:0]}."
                },
                {
                    "opcode": "61",
                    "name": "DS_CONSUME",
                    "short": "LDS & GDS",
                    "description": "LDS & GDS. Subtract (count_bits(exec_mask)) from the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs. The DS will subtract count_bits(vector valid mask) from the value stored at address M0.base + instruction based offset and return the pre-op value to all valid lanes.  This op can be used in both the LDS and GDS.  In the LDS this address will be an offset to HWBASE and clamped by M0.size, but in the GDS the M0.base constant will have the physical GDS address and the compiler must force offset to zero.  In GDS it is for the traditional append buffer operations.  In LDS it is for local thread group appends and can be used to regroup divergent threads.  The use of the M0 register enables the compiler to do indexing of UAV append/consume counters. For GDS (system wide) consume, the compiler must use a zero for {offset1,offset0}, for LDS the compiler will use {offset1,offset0} to provide the relative address to the append counter in the LDS for runtime index offset or index. Inside DS --- Do one atomic add for first valid lane and broadcast result to all valid lanes.  Offset = 0ffset1:offset0; Interpreted as byte offset --- For 10xx LDS designs only aligned atomics are supported, so 2 lsbs of offset must be set to zero. addr = M0.base + offset; // offset by LDS HWBASE, limit to M.size rtnval =  LDS(addr); LDS(addr) = LDS(addr) - countbits(valid mask); GPR[VDST] = rtnval; // return to all valid threads"
                },
                {
                    "opcode": "62",
                    "name": "DS_APPEND",
                    "short": "LDS & GDS",
                    "description": "LDS & GDS. Add (count_bits(exec_mask)) to the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs. The DS will add count_bits(vector valid mask) from the value stored at address M0.base + instruction based offset and return the pre-op value to all valid lanes.  This op can be used in both the LDS and GDS.  In the LDS this address will be an offset to HWBASE and clamped by M0.size, but in the GDS the M0.base constant will have the physical GDS address and the compiler must set offset to zero.  In GDS it is for the traditional append buffer operations.  In LDS it is for local thread group appends and can be used to regroup divergent threads.  The use of the M0 register enables the compiler to do indexing of UAV append/consume counters. For GDS (system wide) consume, the compiler must use a zero for {offset1,offset0}, for LDS the compiler will use {offset1,offset0} to provide the relative address to the append counter in the LDS for runtime index offset or index. Inside DS --- Do one atomic add for first valid lane and broadcast result to all valid lanes.  Offset = 0ffset1:offset0; Interpreted as byte offset --- For 10xx LDS designs only aligned atomics will be supported, so 2 lsbs of offset must be set to zero. addr = M0.base + offset; // offset by LDS HWBASE, limit to M.size rtnval =  LDS(addr); LDS(addr) = LDS(addr) + countbits(valid mask); GPR[VDST] = rtnval; // return to all valid threads"
                },
                {
                    "opcode": "63",
                    "name": "DS_ORDERED_COUNT",
                    "short": "GDS-only",
                    "description": "GDS-only.  Add (count_bits(exec_mask)) to one of 4 dedicated ordered-count counters (aka 'packers').  Additional bits of instr.offset field are overloaded to hold packer-id, 'last'. GDS Only: Intercepted by GDS and processed by ordered append module.  The ordered append module will queue request until this request wave is the oldest in the queue at which time the oldest wave request will be dispatched to the DS with an atomic add for execution and broadcast back to ALL lanes of a wave.  This is an ordered count operation and can only be called once per issue with the release flag set.  If the release flag is not set, the wave will have full control over the order count module until it sends a request with the release flag set. Unlike append/consume this op needs to be sent even if there are no valid lanes when it is issued.  The GDS will add zero and advance the tracking walker that needs to match up with the dispatch counter. The shader will send the following data to identify which wave to return the result to: The shader will send the following pipeline_ID to the ordered count unit to be used to select the correct pipeline's tracking data. Additionally pixel waves will use 4 counters depending on the packer sourcing the pixel waves and generating the launch order. Pipeline_id = ring_id + !pixel wave type; 0 = ring0 pixel wave 1 = ring0 CS 2 = ring1 CS 3 = ring2 CS Physical_wave_id =  {se_id, sh_id, wave_buf_id} GDS_size from the M0.size register contains the pkr_id (set at wave creation time) and logical_wave_id for pixel waves and launch order logical wave_id for compute shaders. The pixel shader uses four counters for each instance, so the pkr_id will need to be added to the gds_base to act on the correct counter. index =  find first valid (vector mask) count = src0[index][31:0]; Pkr_id =  gds_size[1:0]; gds_atomic_address[15:2]  = gds_base[15:2] will contain the dword address in the ds for the count accumulation counter. ds_address[15:2]  =  gds_base[15:2] + offset0[7:2]  + (pipeline_id == 0)?Pkr_id:0 //2 new control signals Wave_release = Offset1[0]; Wave_done = offset1[1]; Pixel_wave = offset1[2]; If this control is not set, hold the crawler until wave does an additional access with the wave_release the wave.  This feature"
                },
                {
                    "opcode": "64",
                    "name": "DS_ADD_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "65",
                    "name": "DS_SUB_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "66",
                    "name": "DS_RSUB_U64",
                    "short": "Subtraction with reversed operands",
                    "description": "Subtraction with reversed operands. // 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA - MEM[ADDR]; RETURN_DATA = tmp."
                },
                {
                    "opcode": "67",
                    "name": "DS_INC_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "68",
                    "name": "DS_DEC_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "69",
                    "name": "DS_MIN_I64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "70",
                    "name": "DS_MAX_I64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "71",
                    "name": "DS_MIN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "72",
                    "name": "DS_MAX_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "73",
                    "name": "DS_AND_B64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "74",
                    "name": "DS_OR_B64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "75",
                    "name": "DS_XOR_B64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "76",
                    "name": "DS_MSKOR_B64",
                    "short": "Masked dword OR, D0 contains the mask and D1 contains the new value",
                    "description": "Masked dword OR, D0 contains the mask and D1 contains the new value. // 64bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR] & ~DATA) | DATA2; RETURN_DATA = tmp."
                },
                {
                    "opcode": "77",
                    "name": "DS_WRITE_B64",
                    "short": "Write qword",
                    "description": "Write qword. // 64bit MEM[ADDR] = DATA."
                },
                {
                    "opcode": "78",
                    "name": "DS_WRITE2_B64",
                    "short": "Write 2 qwords",
                    "description": "Write 2 qwords. // 64bit MEM[ADDR + OFFSET0 * 8] = DATA; MEM[ADDR + OFFSET1 * 8] = DATA2."
                },
                {
                    "opcode": "79",
                    "name": "DS_WRITE2ST64_B64",
                    "short": "Write 2 qwords with a larger stride",
                    "description": "Write 2 qwords with a larger stride. // 64bit MEM[ADDR + OFFSET0 * 8 * 64] = DATA; MEM[ADDR + OFFSET1 * 8 * 64] = DATA2."
                },
                {
                    "opcode": "80",
                    "name": "DS_CMPST_B64",
                    "short": "Compare and store",
                    "description": "Compare and store.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_CMPSWAP_X2 opcode. // 64bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "81",
                    "name": "DS_CMPST_F64",
                    "short": "Floating point compare and store that handles NaN/INF/denormal values",
                    "description": "Floating point compare and store that handles NaN/INF/denormal values.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_FCMPSWAP_X2 opcode. // 64bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "82",
                    "name": "DS_MIN_F64",
                    "short": "Floating point minimum that handles NaN/INF/denormal values",
                    "description": "Floating point minimum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMIN_X2. // 64bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (cmp < tmp) ? src : tmp."
                },
                {
                    "opcode": "83",
                    "name": "DS_MAX_F64",
                    "short": "Floating point maximum that handles NaN/INF/denormal values",
                    "description": "Floating point maximum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMAX_X2. // 64bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (tmp > cmp) ? src : tmp."
                },
                {
                    "opcode": "85",
                    "name": "DS_ADD_RTN_F32",
                    "short": "Floating point add that handles NaN/INF/denormal values",
                    "description": "Floating point add that handles NaN/INF/denormal values. float tmp = MEM[ADDR].f32; MEM[ADDR].f32 += DATA0.f32; VDST.f32 = tmp;"
                },
                {
                    "opcode": "96",
                    "name": "DS_ADD_RTN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "97",
                    "name": "DS_SUB_RTN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "98",
                    "name": "DS_RSUB_RTN_U64",
                    "short": "Subtraction with reversed operands",
                    "description": "Subtraction with reversed operands. // 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA - MEM[ADDR]; RETURN_DATA = tmp."
                },
                {
                    "opcode": "99",
                    "name": "DS_INC_RTN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "100",
                    "name": "DS_DEC_RTN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "101",
                    "name": "DS_MIN_RTN_I64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "102",
                    "name": "DS_MAX_RTN_I64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "103",
                    "name": "DS_MIN_RTN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "104",
                    "name": "DS_MAX_RTN_U64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "105",
                    "name": "DS_AND_RTN_B64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "106",
                    "name": "DS_OR_RTN_B64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "107",
                    "name": "DS_XOR_RTN_B64",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "108",
                    "name": "DS_MSKOR_RTN_B64",
                    "short": "Masked dword OR, D0 contains the mask and D1 contains the new value",
                    "description": "Masked dword OR, D0 contains the mask and D1 contains the new value. // 64bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR] & ~DATA) | DATA2; RETURN_DATA = tmp."
                },
                {
                    "opcode": "109",
                    "name": "DS_WRXCHG_RTN_B64",
                    "short": "Write-exchange operation",
                    "description": "Write-exchange operation. tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "110",
                    "name": "DS_WRXCHG2_RTN_B64",
                    "short": " Write-exchange 2 separate qwords",
                    "description": " Write-exchange 2 separate qwords."
                },
                {
                    "opcode": "111",
                    "name": "DS_WRXCHG2ST64_RTN_B64",
                    "short": " Write-exchange 2 qwords with a stride of 64 qwords",
                    "description": " Write-exchange 2 qwords with a stride of 64 qwords."
                },
                {
                    "opcode": "112",
                    "name": "DS_CMPST_RTN_B64",
                    "short": "Compare and store",
                    "description": "Compare and store.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_CMPSWAP_X2 opcode. // 64bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "113",
                    "name": "DS_CMPST_RTN_F64",
                    "short": "Floating point compare and store that handles NaN/INF/denormal values",
                    "description": "Floating point compare and store that handles NaN/INF/denormal values.  Caution, the order of src and cmp are the *opposite* of the BUFFER_ATOMIC_FCMPSWAP_X2 opcode. // 64bit tmp = MEM[ADDR]; src = DATA2; cmp = DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "114",
                    "name": "DS_MIN_RTN_F64",
                    "short": "Floating point minimum that handles NaN/INF/denormal values",
                    "description": "Floating point minimum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMIN_X2. // 64bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (cmp < tmp) ? src : tmp."
                },
                {
                    "opcode": "115",
                    "name": "DS_MAX_RTN_F64",
                    "short": "Floating point maximum that handles NaN/INF/denormal values",
                    "description": "Floating point maximum that handles NaN/INF/denormal values. Note that this opcode is slightly more general-purpose than BUFFER_ATOMIC_FMAX_X2. // 64bit tmp = MEM[ADDR]; src = DATA; cmp = DATA2; MEM[ADDR] = (tmp > cmp) ? src : tmp."
                },
                {
                    "opcode": "118",
                    "name": "DS_READ_B64",
                    "short": "Read 1 qword",
                    "description": "Read 1 qword. RETURN_DATA = MEM[ADDR]."
                },
                {
                    "opcode": "119",
                    "name": "DS_READ2_B64",
                    "short": "Read 2 qwords",
                    "description": "Read 2 qwords. RETURN_DATA[0] = MEM[ADDR + OFFSET0 * 8]; RETURN_DATA[1] = MEM[ADDR + OFFSET1 * 8]."
                },
                {
                    "opcode": "120",
                    "name": "DS_READ2ST64_B64",
                    "short": "Read 2 qwords with a larger stride",
                    "description": "Read 2 qwords with a larger stride. RETURN_DATA[0] = MEM[ADDR + OFFSET0 * 8 * 64]; RETURN_DATA[1] = MEM[ADDR + OFFSET1 * 8 * 64]."
                },
                {
                    "opcode": "126",
                    "name": "DS_CONDXCHG32_RTN_B64",
                    "short": " Conditional write exchange",
                    "description": " Conditional write exchange."
                },
                {
                    "opcode": "160",
                    "name": "DS_WRITE_B8_D16_HI",
                    "short": "Byte write in to high word",
                    "description": "Byte write in to high word. MEM[ADDR] = DATA[23:16]."
                },
                {
                    "opcode": "161",
                    "name": "DS_WRITE_B16_D16_HI",
                    "short": "Short write in to high word",
                    "description": "Short write in to high word. MEM[ADDR] = DATA[31:16]."
                },
                {
                    "opcode": "162",
                    "name": "DS_READ_U8_D16",
                    "short": "Unsigned byte read with masked return to lower word",
                    "description": "Unsigned byte read with masked return to lower word. RETURN_DATA[15:0] = {8'h0,MEM[ADDR][7:0]}."
                },
                {
                    "opcode": "163",
                    "name": "DS_READ_U8_D16_HI",
                    "short": "Unsigned byte read with masked return to upper word",
                    "description": "Unsigned byte read with masked return to upper word. RETURN_DATA[31:16] = {8'h0,MEM[ADDR][7:0]}."
                },
                {
                    "opcode": "164",
                    "name": "DS_READ_I8_D16",
                    "short": "Signed byte read with masked return to lower word",
                    "description": "Signed byte read with masked return to lower word. RETURN_DATA[15:0] = signext(MEM[ADDR][7:0])."
                },
                {
                    "opcode": "165",
                    "name": "DS_READ_I8_D16_HI",
                    "short": "Signed byte read with masked return to upper word",
                    "description": "Signed byte read with masked return to upper word. RETURN_DATA[31:16] = signext(MEM[ADDR][7:0])."
                },
                {
                    "opcode": "166",
                    "name": "DS_READ_U16_D16",
                    "short": "Unsigned short read with masked return to lower word",
                    "description": "Unsigned short read with masked return to lower word. RETURN_DATA[15:0] = MEM[ADDR][15:0]."
                },
                {
                    "opcode": "167",
                    "name": "DS_READ_U16_D16_HI",
                    "short": "Unsigned short read with masked return to upper word",
                    "description": "Unsigned short read with masked return to upper word. RETURN_DATA[31:0] = MEM[ADDR][15:0]."
                },
                {
                    "opcode": "176",
                    "name": "DS_WRITE_ADDTID_B32",
                    "short": "Write dword with thread ID offset",
                    "description": "Write dword with thread ID offset. LDS_GS[LDS_BASE + {OFFSET1,OFFSET0} + M0[15:0] + TID*4].u32 = VGPR[DATA0].u32"
                },
                {
                    "opcode": "177",
                    "name": "DS_READ_ADDTID_B32",
                    "short": "Dword read with thread ID offset",
                    "description": "Dword read with thread ID offset. VGPR[VDST].u32 = LDS_GS[LDS_BASE + {OFFSET1,OFFSET0} + M0[15:0] + TID*4].u32"
                },
                {
                    "opcode": "178",
                    "name": "DS_PERMUTE_B32",
                    "short": "// VGPR[index][thread_id] is the VGPR RAM // VDST, ADDR and DATA0 are from the microcode DS encoding tmp[0",
                    "description": "// VGPR[index][thread_id] is the VGPR RAM // VDST, ADDR and DATA0 are from the microcode DS encoding tmp[0..63] = 0 for i in 0..63 do // If a source thread is disabled, it will not propagate data. next if !EXEC[i] // ADDR needs to be divided by 4. // High-order bits are ignored. dst_lane = floor((VGPR[ADDR][i] + OFFSET) / 4) mod 64 tmp[dst_lane] = VGPR[DATA0][i] endfor // Copy data into destination VGPRs. If multiple sources // select the same destination thread, the highest-numbered // source thread wins. for i in 0..63 do next if !EXEC[i] VGPR[VDST][i] = tmp[i] endfor Forward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave.  It uses LDS hardware to implement an arbitrary swizzle across threads in a wavefront. Note the address passed in is the thread ID multiplied by 4. If multiple sources map to the same destination lane, the final value is not predictable but will be the value from one of the writers. See also DS_BPERMUTE_B32. Examples (simplified 4-thread wavefronts): VGPR[SRC0] = { A, B, C, D } VGPR[ADDR] = { 0, 0, 12, 4 } EXEC = 0xF, OFFSET = 0 VGPR[VDST] := { B, D, 0, C } VGPR[SRC0] = { A, B, C, D } VGPR[ADDR] = { 0, 0, 12, 4 } EXEC = 0xA, OFFSET = 0 VGPR[VDST] := { -, D, -, 0 }"
                },
                {
                    "opcode": "179",
                    "name": "DS_BPERMUTE_B32",
                    "short": "// VGPR[index][thread_id] is the VGPR RAM // VDST, ADDR and DATA0 are from the microcode DS encoding tmp[0",
                    "description": "// VGPR[index][thread_id] is the VGPR RAM // VDST, ADDR and DATA0 are from the microcode DS encoding tmp[0..63] = 0 for i in 0..63 do // ADDR needs to be divided by 4. // High-order bits are ignored. src_lane = floor((VGPR[ADDR][i] + OFFSET) / 4) mod 64 // EXEC is applied to the source VGPR reads. next if !EXEC[src_lane] tmp[i] = VGPR[DATA0][src_lane] endfor // Copy data into destination VGPRs. Some source // data may be broadcast to multiple lanes. for i in 0..63 do next if !EXEC[i] VGPR[VDST][i] = tmp[i] endfor Backward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave.  It uses LDS hardware to implement an arbitrary swizzle across threads in a wavefront. Note the address passed in is the thread ID multiplied by 4. Note that EXEC mask is applied to both VGPR read and write.  If src_lane selects a disabled thread, zero will be returned. See also DS_PERMUTE_B32. Examples (simplified 4-thread wavefronts): VGPR[SRC0] = { A, B, C, D } VGPR[ADDR] = { 0, 0, 12, 4 } EXEC = 0xF, OFFSET = 0 VGPR[VDST] := { A, A, D, B } VGPR[SRC0] = { A, B, C, D } VGPR[ADDR] = { 0, 0, 12, 4 } EXEC = 0xA, OFFSET = 0 VGPR[VDST] := { -, 0, -, B }"
                },
                {
                    "opcode": "222",
                    "name": "DS_WRITE_B96",
                    "short": "Tri-dword write",
                    "description": "Tri-dword write. {MEM[ADDR + 8], MEM[ADDR + 4], MEM[ADDR]} = DATA[95:0]."
                },
                {
                    "opcode": "223",
                    "name": "DS_WRITE_B128",
                    "short": "Quad-dword write",
                    "description": "Quad-dword write. {MEM[ADDR + 12], MEM[ADDR + 8], MEM[ADDR + 4], MEM[ADDR]} = DATA[127:0]."
                },
                {
                    "opcode": "254",
                    "name": "DS_READ_B96",
                    "short": "Tri-dword read",
                    "description": "Tri-dword read."
                },
                {
                    "opcode": "255",
                    "name": "DS_READ_B128",
                    "short": "Quad-dword read",
                    "description": "Quad-dword read."
                }
            ]
        },
        {
            "key": "mubuf",
            "name": " MUBUF Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "BUFFER_LOAD_FORMAT_X",
                    "short": "Untyped buffer load 1 dword with format conversion",
                    "description": "Untyped buffer load 1 dword with format conversion."
                },
                {
                    "opcode": "1",
                    "name": "BUFFER_LOAD_FORMAT_XY",
                    "short": "Untyped buffer load 2 dwords with format conversion",
                    "description": "Untyped buffer load 2 dwords with format conversion."
                },
                {
                    "opcode": "2",
                    "name": "BUFFER_LOAD_FORMAT_XYZ",
                    "short": "Untyped buffer load 3 dwords with format conversion",
                    "description": "Untyped buffer load 3 dwords with format conversion."
                },
                {
                    "opcode": "3",
                    "name": "BUFFER_LOAD_FORMAT_XYZW",
                    "short": "Untyped buffer load 4 dwords with format conversion",
                    "description": "Untyped buffer load 4 dwords with format conversion."
                },
                {
                    "opcode": "4",
                    "name": "BUFFER_STORE_FORMAT_X",
                    "short": "Untyped buffer store 1 dword with format conversion",
                    "description": "Untyped buffer store 1 dword with format conversion."
                },
                {
                    "opcode": "5",
                    "name": "BUFFER_STORE_FORMAT_XY",
                    "short": "Untyped buffer store 2 dwords with format conversion",
                    "description": "Untyped buffer store 2 dwords with format conversion."
                },
                {
                    "opcode": "6",
                    "name": "BUFFER_STORE_FORMAT_XYZ",
                    "short": "Untyped buffer store 3 dwords with format conversion",
                    "description": "Untyped buffer store 3 dwords with format conversion."
                },
                {
                    "opcode": "7",
                    "name": "BUFFER_STORE_FORMAT_XYZW",
                    "short": "Untyped buffer store 4 dwords with format conversion",
                    "description": "Untyped buffer store 4 dwords with format conversion."
                },
                {
                    "opcode": "8",
                    "name": "BUFFER_LOAD_UBYTE",
                    "short": "Untyped buffer load unsigned byte (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned byte (zero extend to VGPR destination)."
                },
                {
                    "opcode": "9",
                    "name": "BUFFER_LOAD_SBYTE",
                    "short": "Untyped buffer load signed byte (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed byte (sign extend to VGPR destination)."
                },
                {
                    "opcode": "10",
                    "name": "BUFFER_LOAD_USHORT",
                    "short": "Untyped buffer load unsigned short (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned short (zero extend to VGPR destination)."
                },
                {
                    "opcode": "11",
                    "name": "BUFFER_LOAD_SSHORT",
                    "short": "Untyped buffer load signed short (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed short (sign extend to VGPR destination)."
                },
                {
                    "opcode": "12",
                    "name": "BUFFER_LOAD_DWORD",
                    "short": "Untyped buffer load dword",
                    "description": "Untyped buffer load dword."
                },
                {
                    "opcode": "13",
                    "name": "BUFFER_LOAD_DWORDX2",
                    "short": "Untyped buffer load 2 dwords",
                    "description": "Untyped buffer load 2 dwords."
                },
                {
                    "opcode": "14",
                    "name": "BUFFER_LOAD_DWORDX4",
                    "short": "Untyped buffer load 4 dwords",
                    "description": "Untyped buffer load 4 dwords."
                },
                {
                    "opcode": "15",
                    "name": "BUFFER_LOAD_DWORDX3",
                    "short": "Untyped buffer load 3 dwords",
                    "description": "Untyped buffer load 3 dwords."
                },
                {
                    "opcode": "24",
                    "name": "BUFFER_STORE_BYTE",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[7:0]."
                },
                {
                    "opcode": "25",
                    "name": "BUFFER_STORE_BYTE_D16_HI",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[23:16]."
                },
                {
                    "opcode": "26",
                    "name": "BUFFER_STORE_SHORT",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[15:0]."
                },
                {
                    "opcode": "27",
                    "name": "BUFFER_STORE_SHORT_D16_HI",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[31:16]."
                },
                {
                    "opcode": "28",
                    "name": "BUFFER_STORE_DWORD",
                    "short": "Untyped buffer store dword",
                    "description": "Untyped buffer store dword."
                },
                {
                    "opcode": "29",
                    "name": "BUFFER_STORE_DWORDX2",
                    "short": "Untyped buffer store 2 dwords",
                    "description": "Untyped buffer store 2 dwords."
                },
                {
                    "opcode": "30",
                    "name": "BUFFER_STORE_DWORDX4",
                    "short": "Untyped buffer store 4 dwords",
                    "description": "Untyped buffer store 4 dwords."
                },
                {
                    "opcode": "31",
                    "name": "BUFFER_STORE_DWORDX3",
                    "short": "Untyped buffer store 3 dwords",
                    "description": "Untyped buffer store 3 dwords."
                },
                {
                    "opcode": "32",
                    "name": "BUFFER_LOAD_UBYTE_D16",
                    "short": "D0[15:0] = {8'h0, MEM[ADDR]}",
                    "description": "D0[15:0] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "33",
                    "name": "BUFFER_LOAD_UBYTE_D16_HI",
                    "short": "D0[31:16] = {8'h0, MEM[ADDR]}",
                    "description": "D0[31:16] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "34",
                    "name": "BUFFER_LOAD_SBYTE_D16",
                    "short": "D0[15:0] = signext(MEM[ADDR])",
                    "description": "D0[15:0] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "35",
                    "name": "BUFFER_LOAD_SBYTE_D16_HI",
                    "short": "D0[31:16] = signext(MEM[ADDR])",
                    "description": "D0[31:16] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "36",
                    "name": "BUFFER_LOAD_SHORT_D16",
                    "short": "D0[15:0] = MEM[ADDR]",
                    "description": "D0[15:0] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "37",
                    "name": "BUFFER_LOAD_SHORT_D16_HI",
                    "short": "D0[31:16] = MEM[ADDR]",
                    "description": "D0[31:16] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "38",
                    "name": "BUFFER_LOAD_FORMAT_D16_HI_X",
                    "short": " D0[31:16] = MEM[ADDR]",
                    "description": " D0[31:16] = MEM[ADDR]. Untyped buffer load 1 dword with format conversion."
                },
                {
                    "opcode": "39",
                    "name": "BUFFER_STORE_FORMAT_D16_HI_X",
                    "short": " Untyped buffer store 1 dword with format conversion",
                    "description": " Untyped buffer store 1 dword with format conversion."
                },
                {
                    "opcode": "48",
                    "name": "BUFFER_ATOMIC_SWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "49",
                    "name": "BUFFER_ATOMIC_CMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "50",
                    "name": "BUFFER_ATOMIC_ADD",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "51",
                    "name": "BUFFER_ATOMIC_SUB",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "52",
                    "name": "BUFFER_ATOMIC_CSUB",
                    "short": "// 32bit old_value = MEM[ADDR]; if old_value < DATA then new_value = 0; else new_value = old_value - DATA; endif; MEM[addr] = new_value; RETURN_DATA = old_value",
                    "description": "// 32bit old_value = MEM[ADDR]; if old_value < DATA then new_value = 0; else new_value = old_value - DATA; endif; MEM[addr] = new_value; RETURN_DATA = old_value."
                },
                {
                    "opcode": "53",
                    "name": "BUFFER_ATOMIC_SMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "54",
                    "name": "BUFFER_ATOMIC_UMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "55",
                    "name": "BUFFER_ATOMIC_SMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "56",
                    "name": "BUFFER_ATOMIC_UMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "57",
                    "name": "BUFFER_ATOMIC_AND",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "58",
                    "name": "BUFFER_ATOMIC_OR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "59",
                    "name": "BUFFER_ATOMIC_XOR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "60",
                    "name": "BUFFER_ATOMIC_INC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "61",
                    "name": "BUFFER_ATOMIC_DEC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "62",
                    "name": "BUFFER_ATOMIC_FCMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "63",
                    "name": "BUFFER_ATOMIC_FMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "64",
                    "name": "BUFFER_ATOMIC_FMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "80",
                    "name": "BUFFER_ATOMIC_SWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "81",
                    "name": "BUFFER_ATOMIC_CMPSWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "82",
                    "name": "BUFFER_ATOMIC_ADD_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "83",
                    "name": "BUFFER_ATOMIC_SUB_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "85",
                    "name": "BUFFER_ATOMIC_SMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "86",
                    "name": "BUFFER_ATOMIC_UMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "87",
                    "name": "BUFFER_ATOMIC_SMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "88",
                    "name": "BUFFER_ATOMIC_UMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "89",
                    "name": "BUFFER_ATOMIC_AND_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "90",
                    "name": "BUFFER_ATOMIC_OR_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "91",
                    "name": "BUFFER_ATOMIC_XOR_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "92",
                    "name": "BUFFER_ATOMIC_INC_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "93",
                    "name": "BUFFER_ATOMIC_DEC_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "94",
                    "name": "BUFFER_ATOMIC_FCMPSWAP_X2",
                    "short": " // 64bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": " // 64bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "95",
                    "name": "BUFFER_ATOMIC_FMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "96",
                    "name": "BUFFER_ATOMIC_FMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "113",
                    "name": "BUFFER_GL0_INV",
                    "short": "Write back and invalidate the shader L0",
                    "description": "Write back and invalidate the shader L0.  Returns ACK to shader."
                },
                {
                    "opcode": "114",
                    "name": "BUFFER_GL1_INV",
                    "short": "Invalidate the GL1 cache only",
                    "description": "Invalidate the GL1 cache only. Returns ACK to shader."
                },
                {
                    "opcode": "128",
                    "name": "BUFFER_LOAD_FORMAT_D16_X",
                    "short": "Untyped buffer load 1 dword with format conversion",
                    "description": "Untyped buffer load 1 dword with format conversion. D0[15:0] = MEM[ADDR]."
                },
                {
                    "opcode": "129",
                    "name": "BUFFER_LOAD_FORMAT_D16_XY",
                    "short": "Untyped buffer load 1 dword with format conversion",
                    "description": "Untyped buffer load 1 dword with format conversion."
                },
                {
                    "opcode": "130",
                    "name": "BUFFER_LOAD_FORMAT_D16_XY",
                    "short": "Untyped buffer load 2 dwords with format conversion",
                    "description": "Untyped buffer load 2 dwords with format conversion. Z"
                },
                {
                    "opcode": "131",
                    "name": "BUFFER_LOAD_FORMAT_D16_XY",
                    "short": "Untyped buffer load 2 dwords with format conversion",
                    "description": "Untyped buffer load 2 dwords with format conversion. ZW"
                },
                {
                    "opcode": "132",
                    "name": "BUFFER_STORE_FORMAT_D16_X",
                    "short": "Untyped buffer store 1 dword with format conversion",
                    "description": "Untyped buffer store 1 dword with format conversion."
                },
                {
                    "opcode": "133",
                    "name": "BUFFER_STORE_FORMAT_D16_",
                    "short": "Untyped buffer store 1 dword with format conversion",
                    "description": "Untyped buffer store 1 dword with format conversion. XY"
                },
                {
                    "opcode": "134",
                    "name": "BUFFER_STORE_FORMAT_D16_",
                    "short": "Untyped buffer store 2 dwords with format conversion",
                    "description": "Untyped buffer store 2 dwords with format conversion. XYZ"
                },
                {
                    "opcode": "135",
                    "name": "BUFFER_STORE_FORMAT_D16_",
                    "short": "Untyped buffer store 2 dwords with format conversion",
                    "description": "Untyped buffer store 2 dwords with format conversion. XYZW"
                }
            ]
        },
        {
            "key": "mtbuf",
            "name": "MTBUF Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "TBUFFER_LOAD_FORMAT_X",
                    "short": "Typed buffer load 1 dword with format conversion",
                    "description": "Typed buffer load 1 dword with format conversion."
                },
                {
                    "opcode": "1",
                    "name": "TBUFFER_LOAD_FORMAT_XY",
                    "short": "Typed buffer load 2 dwords with format conversion",
                    "description": "Typed buffer load 2 dwords with format conversion."
                },
                {
                    "opcode": "2",
                    "name": "TBUFFER_LOAD_FORMAT_XYZ",
                    "short": "Typed buffer load 3 dwords with format conversion",
                    "description": "Typed buffer load 3 dwords with format conversion."
                },
                {
                    "opcode": "3",
                    "name": "TBUFFER_LOAD_FORMAT_XYZW",
                    "short": "Typed buffer load 4 dwords with format conversion",
                    "description": "Typed buffer load 4 dwords with format conversion."
                },
                {
                    "opcode": "4",
                    "name": "TBUFFER_STORE_FORMAT_X",
                    "short": "Typed buffer store 1 dword with format conversion",
                    "description": "Typed buffer store 1 dword with format conversion."
                },
                {
                    "opcode": "5",
                    "name": "TBUFFER_STORE_FORMAT_XY",
                    "short": "Typed buffer store 2 dwords with format conversion",
                    "description": "Typed buffer store 2 dwords with format conversion."
                },
                {
                    "opcode": "6",
                    "name": "TBUFFER_STORE_FORMAT_XYZ",
                    "short": "Typed buffer store 3 dwords with format conversion",
                    "description": "Typed buffer store 3 dwords with format conversion."
                },
                {
                    "opcode": "7",
                    "name": "TBUFFER_STORE_FORMAT_XYZW",
                    "short": "Typed buffer store 4 dwords with format conversion",
                    "description": "Typed buffer store 4 dwords with format conversion."
                },
                {
                    "opcode": "8",
                    "name": "TBUFFER_LOAD_FORMAT_D16_X",
                    "short": "Typed buffer load 1 dword with format conversion",
                    "description": "Typed buffer load 1 dword with format conversion."
                },
                {
                    "opcode": "9",
                    "name": "TBUFFER_LOAD_FORMAT_D16_XY",
                    "short": "Typed buffer load 1 dword with format conversion",
                    "description": "Typed buffer load 1 dword with format conversion."
                },
                {
                    "opcode": "10",
                    "name": "TBUFFER_LOAD_FORMAT_D16_XYZ",
                    "short": "Typed buffer load 2 dwords with format conversion",
                    "description": "Typed buffer load 2 dwords with format conversion."
                },
                {
                    "opcode": "11",
                    "name": "TBUFFER_LOAD_FORMAT_D16_XYZW",
                    "short": "Typed buffer load 2 dwords with format conversion",
                    "description": "Typed buffer load 2 dwords with format conversion."
                },
                {
                    "opcode": "12",
                    "name": "TBUFFER_STORE_FORMAT_D16_X",
                    "short": "Typed buffer store 1 dword with format conversion",
                    "description": "Typed buffer store 1 dword with format conversion."
                },
                {
                    "opcode": "13",
                    "name": "TBUFFER_STORE_FORMAT_D16_XY",
                    "short": "Typed buffer store 1 dword with format conversion",
                    "description": "Typed buffer store 1 dword with format conversion."
                },
                {
                    "opcode": "14",
                    "name": "TBUFFER_STORE_FORMAT_D16_XYZ",
                    "short": "Typed buffer store 2 dwords with format conversion",
                    "description": "Typed buffer store 2 dwords with format conversion."
                },
                {
                    "opcode": "15",
                    "name": "TBUFFER_STORE_FORMAT_D16_XYZW",
                    "short": "Typed buffer store 2 dwords with format conversion",
                    "description": "Typed buffer store 2 dwords with format conversion."
                }
            ]
        },
        {
            "key": "mimg",
            "name": "MIMG Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "0",
                    "name": "IMAGE_LOAD",
                    "short": "Load element from largest miplevel in resource view, with format conversion specified in the resource constant",
                    "description": "Load element from largest miplevel in resource view, with format conversion specified in the resource constant. No sampler."
                },
                {
                    "opcode": "1",
                    "name": "IMAGE_LOAD_MIP",
                    "short": "Load element from user-specified miplevel in resource view, with format conversion specified in the resource constant",
                    "description": "Load element from user-specified miplevel in resource view, with format conversion specified in the resource constant. No sampler."
                },
                {
                    "opcode": "2",
                    "name": "IMAGE_LOAD_PCK",
                    "short": "Load element from largest miplevel in resource view, without format conversion",
                    "description": "Load element from largest miplevel in resource view, without format conversion. 8- and 16-bit elements are not sign-extended. No sampler."
                },
                {
                    "opcode": "3",
                    "name": "IMAGE_LOAD_PCK_SGN",
                    "short": "Load element from largest miplevel in resource view, without format conversion",
                    "description": "Load element from largest miplevel in resource view, without format conversion. 8- and 16-bit elements are sign-extended. No sampler."
                },
                {
                    "opcode": "4",
                    "name": "IMAGE_LOAD_MIP_PCK",
                    "short": "Load element from user-supplied miplevel in resource view, without format conversion",
                    "description": "Load element from user-supplied miplevel in resource view, without format conversion. 8- and 16-bit elements are not sign-extended. No sampler."
                },
                {
                    "opcode": "5",
                    "name": "IMAGE_LOAD_MIP_PCK_SGN",
                    "short": "Load element from user-supplied miplevel in resource view, without format conversion",
                    "description": "Load element from user-supplied miplevel in resource view, without format conversion. 8- and 16-bit elements are sign-extended. No sampler."
                },
                {
                    "opcode": "8",
                    "name": "IMAGE_STORE",
                    "short": "Store element to largest miplevel in resource view, with format conversion specified in resource constant",
                    "description": "Store element to largest miplevel in resource view, with format conversion specified in resource constant. No sampler."
                },
                {
                    "opcode": "9",
                    "name": "IMAGE_STORE_MIP",
                    "short": "Store element to user-specified miplevel in resource view, with format conversion specified in resource constant",
                    "description": "Store element to user-specified miplevel in resource view, with format conversion specified in resource constant. No sampler."
                },
                {
                    "opcode": "10",
                    "name": "IMAGE_STORE_PCK",
                    "short": "Store element to largest miplevel in resource view, without format conversion",
                    "description": "Store element to largest miplevel in resource view, without format conversion.  No sampler."
                },
                {
                    "opcode": "11",
                    "name": "IMAGE_STORE_MIP_PCK",
                    "short": "Store element to user-specified miplevel in resource view, without format conversion",
                    "description": "Store element to user-specified miplevel in resource view, without format conversion.  No sampler."
                },
                {
                    "opcode": "14",
                    "name": "IMAGE_GET_RESINFO",
                    "short": "Return resource info for a given mip level specified in the address vgpr",
                    "description": "Return resource info for a given mip level specified in the address vgpr. No sampler. Returns 4 integer values into VGPRs 3-0: {num_mip_levels, depth, height, width}."
                },
                {
                    "opcode": "15",
                    "name": "IMAGE_ATOMIC_SWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "16",
                    "name": "IMAGE_ATOMIC_CMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "17",
                    "name": "IMAGE_ATOMIC_ADD",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "18",
                    "name": "IMAGE_ATOMIC_SUB",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "20",
                    "name": "IMAGE_ATOMIC_SMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "21",
                    "name": "IMAGE_ATOMIC_UMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "22",
                    "name": "IMAGE_ATOMIC_SMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "23",
                    "name": "IMAGE_ATOMIC_UMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "24",
                    "name": "IMAGE_ATOMIC_AND",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "25",
                    "name": "IMAGE_ATOMIC_OR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "26",
                    "name": "IMAGE_ATOMIC_XOR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "27",
                    "name": "IMAGE_ATOMIC_INC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "28",
                    "name": "IMAGE_ATOMIC_DEC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "29",
                    "name": "IMAGE_ATOMIC_FCMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "30",
                    "name": "IMAGE_ATOMIC_FMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "31",
                    "name": "IMAGE_ATOMIC_FMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "32",
                    "name": "IMAGE_SAMPLE",
                    "short": "sample texture map",
                    "description": "sample texture map."
                },
                {
                    "opcode": "33",
                    "name": "IMAGE_SAMPLE_CL",
                    "short": "sample texture map, with LOD clamp specified in shader",
                    "description": "sample texture map, with LOD clamp specified in shader."
                },
                {
                    "opcode": "34",
                    "name": "IMAGE_SAMPLE_D",
                    "short": "sample texture map, with user derivatives\n",
                    "description": "sample texture map, with user derivatives"
                },
                {
                    "opcode": "35",
                    "name": "IMAGE_SAMPLE_D_CL",
                    "short": "sample texture map, with LOD clamp specified in shader, with user derivatives",
                    "description": "sample texture map, with LOD clamp specified in shader, with user derivatives."
                },
                {
                    "opcode": "36",
                    "name": "IMAGE_SAMPLE_L",
                    "short": "sample texture map, with user LOD",
                    "description": "sample texture map, with user LOD."
                },
                {
                    "opcode": "37",
                    "name": "IMAGE_SAMPLE_B",
                    "short": "sample texture map, with lod bias",
                    "description": "sample texture map, with lod bias."
                },
                {
                    "opcode": "38",
                    "name": "IMAGE_SAMPLE_B_CL",
                    "short": "sample texture map, with LOD clamp specified in shader, with lod bias",
                    "description": "sample texture map, with LOD clamp specified in shader, with lod bias."
                },
                {
                    "opcode": "39",
                    "name": "IMAGE_SAMPLE_LZ",
                    "short": "sample texture map, from level 0",
                    "description": "sample texture map, from level 0."
                },
                {
                    "opcode": "40",
                    "name": "IMAGE_SAMPLE_C",
                    "short": "sample texture map, with PCF",
                    "description": "sample texture map, with PCF."
                },
                {
                    "opcode": "41",
                    "name": "IMAGE_SAMPLE_C_CL",
                    "short": "SAMPLE_C, with LOD clamp specified in shader",
                    "description": "SAMPLE_C, with LOD clamp specified in shader."
                },
                {
                    "opcode": "42",
                    "name": "IMAGE_SAMPLE_C_D",
                    "short": "SAMPLE_C, with user derivatives",
                    "description": "SAMPLE_C, with user derivatives."
                },
                {
                    "opcode": "43",
                    "name": "IMAGE_SAMPLE_C_D_CL",
                    "short": "SAMPLE_C, with LOD clamp specified in shader, with user derivatives",
                    "description": "SAMPLE_C, with LOD clamp specified in shader, with user derivatives."
                },
                {
                    "opcode": "44",
                    "name": "IMAGE_SAMPLE_C_L",
                    "short": "SAMPLE_C, with user LOD",
                    "description": "SAMPLE_C, with user LOD."
                },
                {
                    "opcode": "45",
                    "name": "IMAGE_SAMPLE_C_B",
                    "short": "SAMPLE_C, with lod bias",
                    "description": "SAMPLE_C, with lod bias."
                },
                {
                    "opcode": "46",
                    "name": "IMAGE_SAMPLE_C_B_CL",
                    "short": "SAMPLE_C, with LOD clamp specified in shader, with lod bias",
                    "description": "SAMPLE_C, with LOD clamp specified in shader, with lod bias."
                },
                {
                    "opcode": "47",
                    "name": "IMAGE_SAMPLE_C_LZ",
                    "short": "SAMPLE_C, from level 0",
                    "description": "SAMPLE_C, from level 0."
                },
                {
                    "opcode": "48",
                    "name": "IMAGE_SAMPLE_O",
                    "short": "sample texture map, with user offsets",
                    "description": "sample texture map, with user offsets."
                },
                {
                    "opcode": "49",
                    "name": "IMAGE_SAMPLE_CL_O",
                    "short": "SAMPLE_O with LOD clamp specified in shader",
                    "description": "SAMPLE_O with LOD clamp specified in shader."
                },
                {
                    "opcode": "50",
                    "name": "IMAGE_SAMPLE_D_O",
                    "short": "SAMPLE_O, with user derivatives",
                    "description": "SAMPLE_O, with user derivatives."
                },
                {
                    "opcode": "51",
                    "name": "IMAGE_SAMPLE_D_CL_O",
                    "short": "SAMPLE_O, with LOD clamp specified in shader, with user derivatives",
                    "description": "SAMPLE_O, with LOD clamp specified in shader, with user derivatives."
                },
                {
                    "opcode": "52",
                    "name": "IMAGE_SAMPLE_L_O",
                    "short": "SAMPLE_O, with user LOD",
                    "description": "SAMPLE_O, with user LOD."
                },
                {
                    "opcode": "53",
                    "name": "IMAGE_SAMPLE_B_O",
                    "short": "SAMPLE_O, with lod bias",
                    "description": "SAMPLE_O, with lod bias."
                },
                {
                    "opcode": "54",
                    "name": "IMAGE_SAMPLE_B_CL_O",
                    "short": "SAMPLE_O, with LOD clamp specified in shader, with lod bias",
                    "description": "SAMPLE_O, with LOD clamp specified in shader, with lod bias."
                },
                {
                    "opcode": "55",
                    "name": "IMAGE_SAMPLE_LZ_O",
                    "short": "SAMPLE_O, from level 0",
                    "description": "SAMPLE_O, from level 0."
                },
                {
                    "opcode": "56",
                    "name": "IMAGE_SAMPLE_C_O",
                    "short": "SAMPLE_C with user specified offsets",
                    "description": "SAMPLE_C with user specified offsets."
                },
                {
                    "opcode": "57",
                    "name": "IMAGE_SAMPLE_C_CL_O",
                    "short": "SAMPLE_C_O, with LOD clamp specified in shader",
                    "description": "SAMPLE_C_O, with LOD clamp specified in shader."
                },
                {
                    "opcode": "58",
                    "name": "IMAGE_SAMPLE_C_D_O",
                    "short": "SAMPLE_C_O, with user derivatives",
                    "description": "SAMPLE_C_O, with user derivatives."
                },
                {
                    "opcode": "59",
                    "name": "IMAGE_SAMPLE_C_D_CL_O",
                    "short": "SAMPLE_C_O, with LOD clamp specified in shader, with user derivatives",
                    "description": "SAMPLE_C_O, with LOD clamp specified in shader, with user derivatives."
                },
                {
                    "opcode": "60",
                    "name": "IMAGE_SAMPLE_C_L_O",
                    "short": "SAMPLE_C_O, with user LOD",
                    "description": "SAMPLE_C_O, with user LOD."
                },
                {
                    "opcode": "61",
                    "name": "IMAGE_SAMPLE_C_B_O",
                    "short": "SAMPLE_C_O, with lod bias",
                    "description": "SAMPLE_C_O, with lod bias."
                },
                {
                    "opcode": "62",
                    "name": "IMAGE_SAMPLE_C_B_CL_O",
                    "short": "SAMPLE_C_O, with LOD clamp specified in shader, with lod bias",
                    "description": "SAMPLE_C_O, with LOD clamp specified in shader, with lod bias."
                },
                {
                    "opcode": "63",
                    "name": "IMAGE_SAMPLE_C_LZ_O",
                    "short": "SAMPLE_C_O, from level 0",
                    "description": "SAMPLE_C_O, from level 0."
                },
                {
                    "opcode": "64",
                    "name": "IMAGE_GATHER4",
                    "short": "gather 4 single component elements (2x2)",
                    "description": "gather 4 single component elements (2x2)."
                },
                {
                    "opcode": "65",
                    "name": "IMAGE_GATHER4_CL",
                    "short": "gather 4 single component elements (2x2) with user LOD clamp",
                    "description": "gather 4 single component elements (2x2) with user LOD clamp."
                },
                {
                    "opcode": "68",
                    "name": "IMAGE_GATHER4_L",
                    "short": "gather 4 single component elements (2x2) with user LOD",
                    "description": "gather 4 single component elements (2x2) with user LOD."
                },
                {
                    "opcode": "69",
                    "name": "IMAGE_GATHER4_B",
                    "short": "gather 4 single component elements (2x2) with user bias",
                    "description": "gather 4 single component elements (2x2) with user bias."
                },
                {
                    "opcode": "70",
                    "name": "IMAGE_GATHER4_B_CL",
                    "short": "gather 4 single component elements (2x2) with user bias and clamp",
                    "description": "gather 4 single component elements (2x2) with user bias and clamp."
                },
                {
                    "opcode": "71",
                    "name": "IMAGE_GATHER4_LZ",
                    "short": "gather 4 single component elements (2x2) at level 0",
                    "description": "gather 4 single component elements (2x2) at level 0."
                },
                {
                    "opcode": "72",
                    "name": "IMAGE_GATHER4_C",
                    "short": "gather 4 single component elements (2x2) with PCF",
                    "description": "gather 4 single component elements (2x2) with PCF."
                },
                {
                    "opcode": "73",
                    "name": "IMAGE_GATHER4_C_CL",
                    "short": "gather 4 single component elements (2x2) with user LOD clamp and PCF",
                    "description": "gather 4 single component elements (2x2) with user LOD clamp and PCF."
                },
                {
                    "opcode": "76",
                    "name": "IMAGE_GATHER4_C_L",
                    "short": "gather 4 single component elements (2x2) with user LOD and PCF",
                    "description": "gather 4 single component elements (2x2) with user LOD and PCF."
                },
                {
                    "opcode": "77",
                    "name": "IMAGE_GATHER4_C_B",
                    "short": "gather 4 single component elements (2x2) with user bias and PCF",
                    "description": "gather 4 single component elements (2x2) with user bias and PCF."
                },
                {
                    "opcode": "78",
                    "name": "IMAGE_GATHER4_C_B_CL",
                    "short": "gather 4 single component elements (2x2) with user bias, clamp and PCF",
                    "description": "gather 4 single component elements (2x2) with user bias, clamp and PCF."
                },
                {
                    "opcode": "79",
                    "name": "IMAGE_GATHER4_C_LZ",
                    "short": "gather 4 single component elements (2x2) at level 0, with PCF",
                    "description": "gather 4 single component elements (2x2) at level 0, with PCF."
                },
                {
                    "opcode": "80",
                    "name": "IMAGE_GATHER4_O",
                    "short": "GATHER4, with user offsets",
                    "description": "GATHER4, with user offsets."
                },
                {
                    "opcode": "81",
                    "name": "IMAGE_GATHER4_CL_O",
                    "short": "GATHER4_CL, with user offsets",
                    "description": "GATHER4_CL, with user offsets."
                },
                {
                    "opcode": "84",
                    "name": "IMAGE_GATHER4_L_O",
                    "short": "GATHER4_L, with user offsets",
                    "description": "GATHER4_L, with user offsets."
                },
                {
                    "opcode": "85",
                    "name": "IMAGE_GATHER4_B_O",
                    "short": "GATHER4_B, with user offsets",
                    "description": "GATHER4_B, with user offsets."
                },
                {
                    "opcode": "86",
                    "name": "IMAGE_GATHER4_B_CL_O",
                    "short": "GATHER4_B_CL, with user offsets",
                    "description": "GATHER4_B_CL, with user offsets."
                },
                {
                    "opcode": "87",
                    "name": "IMAGE_GATHER4_LZ_O",
                    "short": "GATHER4_LZ, with user offsets",
                    "description": "GATHER4_LZ, with user offsets."
                },
                {
                    "opcode": "88",
                    "name": "IMAGE_GATHER4_C_O",
                    "short": "GATHER4_C, with user offsets",
                    "description": "GATHER4_C, with user offsets."
                },
                {
                    "opcode": "89",
                    "name": "IMAGE_GATHER4_C_CL_O",
                    "short": "GATHER4_C_CL, with user offsets",
                    "description": "GATHER4_C_CL, with user offsets."
                },
                {
                    "opcode": "92",
                    "name": "IMAGE_GATHER4_C_L_O",
                    "short": "GATHER4_C_L, with user offsets",
                    "description": "GATHER4_C_L, with user offsets."
                },
                {
                    "opcode": "93",
                    "name": "IMAGE_GATHER4_C_B_O",
                    "short": "GATHER4_B, with user offsets",
                    "description": "GATHER4_B, with user offsets."
                },
                {
                    "opcode": "94",
                    "name": "IMAGE_GATHER4_C_B_CL_O",
                    "short": "GATHER4_B_CL, with user offsets",
                    "description": "GATHER4_B_CL, with user offsets."
                },
                {
                    "opcode": "95",
                    "name": "IMAGE_GATHER4_C_LZ_O",
                    "short": "GATHER4_C_LZ, with user offsets",
                    "description": "GATHER4_C_LZ, with user offsets."
                },
                {
                    "opcode": "96",
                    "name": "IMAGE_GET_LOD",
                    "short": "VDATA[0] = clampedLOD; VDATA[1] = rawLOD",
                    "description": "VDATA[0] = clampedLOD; VDATA[1] = rawLOD. Return calculated LOD as two 32-bit floating point values."
                },
                {
                    "opcode": "97",
                    "name": "IMAGE_GATHER4H",
                    "short": "Fetch 1 component per texel from 4x1 texels",
                    "description": "Fetch 1 component per texel from 4x1 texels.  DMASK selects which component to read (R,G,B,A) and must have only one bit set to 1."
                },
                {
                    "opcode": "128",
                    "name": "IMAGE_MSAA_LOAD",
                    "short": "Load up to 4 samples of 1 component from an MSAA resource with a user-specified fragment ID",
                    "description": "Load up to 4 samples of 1 component from an MSAA resource with a user-specified fragment ID. No sampler."
                },
                {
                    "opcode": "162",
                    "name": "IMAGE_SAMPLE_D_G16",
                    "short": "SAMPLE_D with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_D with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "163",
                    "name": "IMAGE_SAMPLE_D_CL_G16",
                    "short": "SAMPLE_D_CL with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_D_CL with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "170",
                    "name": "IMAGE_SAMPLE_C_D_G16",
                    "short": "SAMPLE_C_D with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_C_D with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "171",
                    "name": "IMAGE_SAMPLE_C_D_CL_G16",
                    "short": "SAMPLE_C_D_CL with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_C_D_CL with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "178",
                    "name": "IMAGE_SAMPLE_D_O_G16",
                    "short": "SAMPLE_D_O with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_D_O with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "179",
                    "name": "IMAGE_SAMPLE_D_CL_O_G16",
                    "short": "SAMPLE_D_CL_O with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_D_CL_O with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "186",
                    "name": "IMAGE_SAMPLE_C_D_O_G16",
                    "short": "SAMPLE_C_D_O with 16-bit floating point derivatives (gradients)\n",
                    "description": "SAMPLE_C_D_O with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "187",
                    "name": "IMAGE_SAMPLE_C_D_CL_O_G16",
                    "short": " SAMPLE_C_D_CL_O with 16-bit floating point derivatives (gradients)\n",
                    "description": " SAMPLE_C_D_CL_O with 16-bit floating point derivatives (gradients)"
                },
                {
                    "opcode": "230",
                    "name": "IMAGE_BVH_INTERSECT_RAY",
                    "short": "Intersection test on bound volume hierarchy nodes for ray tracing acceleration",
                    "description": "Intersection test on bound volume hierarchy nodes for ray tracing acceleration.  32-bit node pointer.  No sampler. DATA: The destination VGPRs contain the results of intersection testing.  The values returned here are different depending on the type of BVH node that was fetched. For box nodes the results contain the 4 pointers of the children boxes in intersection time sorted order. For triangle BVH nodes the results contain the intersection time and triangle ID of the triangle tested. ADDR: 11 address VGPRs contain the ray data and BVH node pointer for the intersection test.  The data is laid out as follows: vgpr_a[0] = node_pointer (uint32) vgpr_a[1] = ray_extent (float32) vgpr_a[2] = ray_origin.x (float32) vgpr_a[3] = ray_origin.y (float32) vgpr_a[4] = ray_origin.z (float32) vgpr_a[5] = ray_dir.x (float32) vgpr_a[6] = ray_dir.y (float32) vgpr_a[7] = ray_dir.z (float32) vgpr_a[8] = ray_inv_dir.x (float32) vgpr_a[9] = ray_inv_dir.y (float32) vgpr_a[10]= ray_inv_dir.z (float32) For performance and power optimization, the instruction can be encoded to use 16 bit floats for ray_dir and ray_inv_dir by setting A16 to 1. When the instruction is encoded with 16 bit addresses only 8 address VGPRs are used as follows: vgpr_a[0] = node_pointer (uint32) vgpr_a[1] = ray_extent (float32) vgpr_a[2] = ray_origin.x (float32) vgpr_a[3] = ray_origin.y (float32) vgpr_a[4] = ray_origin.z (float32) vgpr_a[5] = {ray_dir.x,ray_dir.y}(2x float16) vgpr_a[6] = {ray_dir.z,ray_inv_dir.x}(2x float16) vgpr_a[7] = {ray_inv_dir.y,ray_inv_dir.z}(2x float16) RSRC: The resource is the texture descriptor for the operation.  The instruction must e encoded with r128=1. RESTRICTIONS: The image_bvh_intersect_ray and image_bvh64_intersect_ray opcode do not support all of"
                }
            ]
        },
        {
            "key": "flat",
            "name": " Flat Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "8",
                    "name": "FLAT_LOAD_UBYTE",
                    "short": "Untyped buffer load unsigned byte (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned byte (zero extend to VGPR destination)."
                },
                {
                    "opcode": "9",
                    "name": "FLAT_LOAD_SBYTE",
                    "short": "Untyped buffer load signed byte (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed byte (sign extend to VGPR destination)."
                },
                {
                    "opcode": "10",
                    "name": "FLAT_LOAD_USHORT",
                    "short": "Untyped buffer load unsigned short (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned short (zero extend to VGPR destination)."
                },
                {
                    "opcode": "11",
                    "name": "FLAT_LOAD_SSHORT",
                    "short": "Untyped buffer load signed short (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed short (sign extend to VGPR destination)."
                },
                {
                    "opcode": "12",
                    "name": "FLAT_LOAD_DWORD",
                    "short": "Untyped buffer load dword",
                    "description": "Untyped buffer load dword."
                },
                {
                    "opcode": "13",
                    "name": "FLAT_LOAD_DWORDX2",
                    "short": "Untyped buffer load 2 dwords",
                    "description": "Untyped buffer load 2 dwords."
                },
                {
                    "opcode": "14",
                    "name": "FLAT_LOAD_DWORDX4",
                    "short": "Untyped buffer load 4 dwords",
                    "description": "Untyped buffer load 4 dwords."
                },
                {
                    "opcode": "15",
                    "name": "FLAT_LOAD_DWORDX3",
                    "short": "Untyped buffer load 3 dwords",
                    "description": "Untyped buffer load 3 dwords."
                },
                {
                    "opcode": "24",
                    "name": "FLAT_STORE_BYTE",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[7:0]."
                },
                {
                    "opcode": "25",
                    "name": "FLAT_STORE_BYTE_D16_HI",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[23:16]."
                },
                {
                    "opcode": "26",
                    "name": "FLAT_STORE_SHORT",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[15:0]."
                },
                {
                    "opcode": "27",
                    "name": "FLAT_STORE_SHORT_D16_HI",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[31:16]."
                },
                {
                    "opcode": "28",
                    "name": "FLAT_STORE_DWORD",
                    "short": "Untyped buffer store dword",
                    "description": "Untyped buffer store dword."
                },
                {
                    "opcode": "29",
                    "name": "FLAT_STORE_DWORDX2",
                    "short": "Untyped buffer store 2 dwords",
                    "description": "Untyped buffer store 2 dwords."
                },
                {
                    "opcode": "30",
                    "name": "FLAT_STORE_DWORDX4",
                    "short": "Untyped buffer store 4 dwords",
                    "description": "Untyped buffer store 4 dwords."
                },
                {
                    "opcode": "31",
                    "name": "FLAT_STORE_DWORDX3",
                    "short": "Untyped buffer store 3 dwords",
                    "description": "Untyped buffer store 3 dwords."
                },
                {
                    "opcode": "32",
                    "name": "FLAT_LOAD_UBYTE_D16",
                    "short": "D0[15:0] = {8'h0, MEM[ADDR]}",
                    "description": "D0[15:0] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "33",
                    "name": "FLAT_LOAD_UBYTE_D16_HI",
                    "short": "D0[31:16] = {8'h0, MEM[ADDR]}",
                    "description": "D0[31:16] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "34",
                    "name": "FLAT_LOAD_SBYTE_D16",
                    "short": "D0[15:0] = signext(MEM[ADDR])",
                    "description": "D0[15:0] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "35",
                    "name": "FLAT_LOAD_SBYTE_D16_HI",
                    "short": "D0[31:16] = signext(MEM[ADDR])",
                    "description": "D0[31:16] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "36",
                    "name": "FLAT_LOAD_SHORT_D16",
                    "short": "D0[15:0] = MEM[ADDR]",
                    "description": "D0[15:0] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "37",
                    "name": "FLAT_LOAD_SHORT_D16_HI",
                    "short": "D0[31:16] = MEM[ADDR]",
                    "description": "D0[31:16] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "48",
                    "name": "FLAT_ATOMIC_SWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "49",
                    "name": "FLAT_ATOMIC_CMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "50",
                    "name": "FLAT_ATOMIC_ADD",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "51",
                    "name": "FLAT_ATOMIC_SUB",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "53",
                    "name": "FLAT_ATOMIC_SMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "54",
                    "name": "FLAT_ATOMIC_UMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "55",
                    "name": "FLAT_ATOMIC_SMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "56",
                    "name": "FLAT_ATOMIC_UMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "57",
                    "name": "FLAT_ATOMIC_AND",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "58",
                    "name": "FLAT_ATOMIC_OR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "59",
                    "name": "FLAT_ATOMIC_XOR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "60",
                    "name": "FLAT_ATOMIC_INC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "61",
                    "name": "FLAT_ATOMIC_DEC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "62",
                    "name": "FLAT_ATOMIC_FCMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "63",
                    "name": "FLAT_ATOMIC_FMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "64",
                    "name": "FLAT_ATOMIC_FMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "80",
                    "name": "FLAT_ATOMIC_SWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "81",
                    "name": "FLAT_ATOMIC_CMPSWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "82",
                    "name": "FLAT_ATOMIC_ADD_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "83",
                    "name": "FLAT_ATOMIC_SUB_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "85",
                    "name": "FLAT_ATOMIC_SMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "86",
                    "name": "FLAT_ATOMIC_UMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "87",
                    "name": "FLAT_ATOMIC_SMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "88",
                    "name": "FLAT_ATOMIC_UMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "89",
                    "name": "FLAT_ATOMIC_AND_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "90",
                    "name": "FLAT_ATOMIC_OR_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "91",
                    "name": "FLAT_ATOMIC_XOR_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "92",
                    "name": "FLAT_ATOMIC_INC_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "93",
                    "name": "FLAT_ATOMIC_DEC_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "94",
                    "name": "FLAT_ATOMIC_FCMPSWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "95",
                    "name": "FLAT_ATOMIC_FMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "96",
                    "name": "FLAT_ATOMIC_FMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                }
            ]
        },
        {
            "key": "scratch",
            "name": " Scratch Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "8",
                    "name": "SCRATCH_LOAD_UBYTE",
                    "short": "Untyped buffer load unsigned byte (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned byte (zero extend to VGPR destination)."
                },
                {
                    "opcode": "9",
                    "name": "SCRATCH_LOAD_SBYTE",
                    "short": "Untyped buffer load signed byte (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed byte (sign extend to VGPR destination)."
                },
                {
                    "opcode": "10",
                    "name": "SCRATCH_LOAD_USHORT",
                    "short": "Untyped buffer load unsigned short (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned short (zero extend to VGPR destination)."
                },
                {
                    "opcode": "11",
                    "name": "SCRATCH_LOAD_SSHORT",
                    "short": "Untyped buffer load signed short (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed short (sign extend to VGPR destination)."
                },
                {
                    "opcode": "12",
                    "name": "SCRATCH_LOAD_DWORD",
                    "short": "Untyped buffer load dword",
                    "description": "Untyped buffer load dword."
                },
                {
                    "opcode": "13",
                    "name": "SCRATCH_LOAD_DWORDX2",
                    "short": "Untyped buffer load 2 dwords",
                    "description": "Untyped buffer load 2 dwords."
                },
                {
                    "opcode": "14",
                    "name": "SCRATCH_LOAD_DWORDX4",
                    "short": "Untyped buffer load 4 dwords",
                    "description": "Untyped buffer load 4 dwords."
                },
                {
                    "opcode": "15",
                    "name": "SCRATCH_LOAD_DWORDX3",
                    "short": "Untyped buffer load 3 dwords",
                    "description": "Untyped buffer load 3 dwords."
                },
                {
                    "opcode": "24",
                    "name": "SCRATCH_STORE_BYTE",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[7:0]."
                },
                {
                    "opcode": "25",
                    "name": "SCRATCH_STORE_BYTE_D16_HI",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[23:16]."
                },
                {
                    "opcode": "26",
                    "name": "SCRATCH_STORE_SHORT",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[15:0]."
                },
                {
                    "opcode": "27",
                    "name": "SCRATCH_STORE_SHORT_D16_HI",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[31:16]."
                },
                {
                    "opcode": "28",
                    "name": "SCRATCH_STORE_DWORD",
                    "short": "Untyped buffer store dword",
                    "description": "Untyped buffer store dword."
                },
                {
                    "opcode": "29",
                    "name": "SCRATCH_STORE_DWORDX2",
                    "short": "Untyped buffer store 2 dwords",
                    "description": "Untyped buffer store 2 dwords."
                },
                {
                    "opcode": "30",
                    "name": "SCRATCH_STORE_DWORDX4",
                    "short": "Untyped buffer store 4 dwords",
                    "description": "Untyped buffer store 4 dwords."
                },
                {
                    "opcode": "31",
                    "name": "SCRATCH_STORE_DWORDX3",
                    "short": "Untyped buffer store 3 dwords",
                    "description": "Untyped buffer store 3 dwords."
                },
                {
                    "opcode": "32",
                    "name": "SCRATCH_LOAD_UBYTE_D16",
                    "short": "D0[15:0] = {8'h0, MEM[ADDR]}",
                    "description": "D0[15:0] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "33",
                    "name": "SCRATCH_LOAD_UBYTE_D16_HI",
                    "short": "D0[31:16] = {8'h0, MEM[ADDR]}",
                    "description": "D0[31:16] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "34",
                    "name": "SCRATCH_LOAD_SBYTE_D16",
                    "short": "D0[15:0] = signext(MEM[ADDR])",
                    "description": "D0[15:0] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "35",
                    "name": "SCRATCH_LOAD_SBYTE_D16_HI",
                    "short": "D0[31:16] = signext(MEM[ADDR])",
                    "description": "D0[31:16] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "36",
                    "name": "SCRATCH_LOAD_SHORT_D16",
                    "short": "D0[15:0] = MEM[ADDR]",
                    "description": "D0[15:0] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "37",
                    "name": "SCRATCH_LOAD_SHORT_D16_HI",
                    "short": "D0[31:16] = MEM[ADDR]",
                    "description": "D0[31:16] = MEM[ADDR]. Untyped buffer load short."
                }
            ]
        },
        {
            "key": "global",
            "name": "Global Instructions",
            "format": [],
            "instructions": [
                {
                    "opcode": "8",
                    "name": "GLOBAL_LOAD_UBYTE",
                    "short": "Untyped buffer load unsigned byte (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned byte (zero extend to VGPR destination)."
                },
                {
                    "opcode": "9",
                    "name": "GLOBAL_LOAD_SBYTE",
                    "short": "Untyped buffer load signed byte (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed byte (sign extend to VGPR destination)."
                },
                {
                    "opcode": "10",
                    "name": "GLOBAL_LOAD_USHORT",
                    "short": "Untyped buffer load unsigned short (zero extend to VGPR destination)",
                    "description": "Untyped buffer load unsigned short (zero extend to VGPR destination)."
                },
                {
                    "opcode": "11",
                    "name": "GLOBAL_LOAD_SSHORT",
                    "short": "Untyped buffer load signed short (sign extend to VGPR destination)",
                    "description": "Untyped buffer load signed short (sign extend to VGPR destination)."
                },
                {
                    "opcode": "12",
                    "name": "GLOBAL_LOAD_DWORD",
                    "short": "Untyped buffer load dword",
                    "description": "Untyped buffer load dword."
                },
                {
                    "opcode": "13",
                    "name": "GLOBAL_LOAD_DWORDX2",
                    "short": "Untyped buffer load 2 dwords",
                    "description": "Untyped buffer load 2 dwords."
                },
                {
                    "opcode": "14",
                    "name": "GLOBAL_LOAD_DWORDX4",
                    "short": "Untyped buffer load 4 dwords",
                    "description": "Untyped buffer load 4 dwords."
                },
                {
                    "opcode": "15",
                    "name": "GLOBAL_LOAD_DWORDX3",
                    "short": "Untyped buffer load 3 dwords",
                    "description": "Untyped buffer load 3 dwords."
                },
                {
                    "opcode": "22",
                    "name": "GLOBAL_LOAD_DWORD_ADDTI",
                    "short": "Untyped buffer load dword",
                    "description": "Untyped buffer load dword.  No VGPR address is supplied D in this instruction.  TID is added to the address as shown below: memory_Addr = sgpr_addr(64) + inst_offset(12) + tid*4"
                },
                {
                    "opcode": "23",
                    "name": "GLOBAL_STORE_DWORD_ADD",
                    "short": "Untyped buffer store dword",
                    "description": "Untyped buffer store dword.  No VGPR address is supplied TID in this instruction.  TID is added to the address as shown below: memory_Addr = sgpr_addr(64) + inst_offset(12) + tid*4"
                },
                {
                    "opcode": "24",
                    "name": "GLOBAL_STORE_BYTE",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[7:0]."
                },
                {
                    "opcode": "25",
                    "name": "GLOBAL_STORE_BYTE_D16_HI",
                    "short": "Untyped buffer store byte",
                    "description": "Untyped buffer store byte. Stores S0[23:16]."
                },
                {
                    "opcode": "26",
                    "name": "GLOBAL_STORE_SHORT",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[15:0]."
                },
                {
                    "opcode": "27",
                    "name": "GLOBAL_STORE_SHORT_D16_",
                    "short": "Untyped buffer store short",
                    "description": "Untyped buffer store short. Stores S0[31:16]. HI"
                },
                {
                    "opcode": "28",
                    "name": "GLOBAL_STORE_DWORD",
                    "short": "Untyped buffer store dword",
                    "description": "Untyped buffer store dword."
                },
                {
                    "opcode": "29",
                    "name": "GLOBAL_STORE_DWORDX2",
                    "short": "Untyped buffer store 2 dwords",
                    "description": "Untyped buffer store 2 dwords."
                },
                {
                    "opcode": "30",
                    "name": "GLOBAL_STORE_DWORDX4",
                    "short": "Untyped buffer store 4 dwords",
                    "description": "Untyped buffer store 4 dwords."
                },
                {
                    "opcode": "31",
                    "name": "GLOBAL_STORE_DWORDX3",
                    "short": "Untyped buffer store 3 dwords",
                    "description": "Untyped buffer store 3 dwords."
                },
                {
                    "opcode": "32",
                    "name": "GLOBAL_LOAD_UBYTE_D16",
                    "short": "D0[15:0] = {8'h0, MEM[ADDR]}",
                    "description": "D0[15:0] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "33",
                    "name": "GLOBAL_LOAD_UBYTE_D16_HI",
                    "short": "D0[31:16] = {8'h0, MEM[ADDR]}",
                    "description": "D0[31:16] = {8'h0, MEM[ADDR]}. Untyped buffer load unsigned byte."
                },
                {
                    "opcode": "34",
                    "name": "GLOBAL_LOAD_SBYTE_D16",
                    "short": "D0[15:0] = signext(MEM[ADDR])",
                    "description": "D0[15:0] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "35",
                    "name": "GLOBAL_LOAD_SBYTE_D16_HI",
                    "short": "D0[31:16] = signext(MEM[ADDR])",
                    "description": "D0[31:16] = signext(MEM[ADDR]). Untyped buffer load signed byte."
                },
                {
                    "opcode": "36",
                    "name": "GLOBAL_LOAD_SHORT_D16",
                    "short": "D0[15:0] = MEM[ADDR]",
                    "description": "D0[15:0] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "37",
                    "name": "GLOBAL_LOAD_SHORT_D16_HI",
                    "short": "D0[31:16] = MEM[ADDR]",
                    "description": "D0[31:16] = MEM[ADDR]. Untyped buffer load short."
                },
                {
                    "opcode": "48",
                    "name": "GLOBAL_ATOMIC_SWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "49",
                    "name": "GLOBAL_ATOMIC_CMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp."
                },
                {
                    "opcode": "50",
                    "name": "GLOBAL_ATOMIC_ADD",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "51",
                    "name": "GLOBAL_ATOMIC_SUB",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "52",
                    "name": "GLOBAL_ATOMIC_CSUB",
                    "short": "// 32bit old_value = MEM[ADDR]; if old_value < DATA then new_value = 0; else new_value = old_value - DATA; endif; MEM[addr] = new_value; RETURN_DATA = old_value",
                    "description": "// 32bit old_value = MEM[ADDR]; if old_value < DATA then new_value = 0; else new_value = old_value - DATA; endif; MEM[addr] = new_value; RETURN_DATA = old_value."
                },
                {
                    "opcode": "53",
                    "name": "GLOBAL_ATOMIC_SMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "54",
                    "name": "GLOBAL_ATOMIC_UMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA < tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "55",
                    "name": "GLOBAL_ATOMIC_SMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // signed compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "56",
                    "name": "GLOBAL_ATOMIC_UMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA > tmp) ? DATA : tmp; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "57",
                    "name": "GLOBAL_ATOMIC_AND",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "58",
                    "name": "GLOBAL_ATOMIC_OR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "59",
                    "name": "GLOBAL_ATOMIC_XOR",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA; RETURN_DATA = tmp."
                },
                {
                    "opcode": "60",
                    "name": "GLOBAL_ATOMIC_INC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA) ? 0 : tmp + 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "61",
                    "name": "GLOBAL_ATOMIC_DEC",
                    "short": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA) ? DATA : tmp - 1; // unsigned compare RETURN_DATA = tmp."
                },
                {
                    "opcode": "62",
                    "name": "GLOBAL_ATOMIC_FCMPSWAP",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "63",
                    "name": "GLOBAL_ATOMIC_FMIN",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "64",
                    "name": "GLOBAL_ATOMIC_FMAX",
                    "short": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 32bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src > tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "80",
                    "name": "GLOBAL_ATOMIC_SWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "81",
                    "name": "GLOBAL_ATOMIC_CMPSWAP_X2",
                    "short": " // 64bit tmp = MEM[ADDR]; src = DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0:1] = tmp",
                    "description": " // 64bit tmp = MEM[ADDR]; src = DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "82",
                    "name": "GLOBAL_ATOMIC_ADD_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] += DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "83",
                    "name": "GLOBAL_ATOMIC_SUB_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "85",
                    "name": "GLOBAL_ATOMIC_SMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "86",
                    "name": "GLOBAL_ATOMIC_UMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] < tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "87",
                    "name": "GLOBAL_ATOMIC_SMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // signed compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "88",
                    "name": "GLOBAL_ATOMIC_UMAX_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA[0:1] > tmp) ? DATA[0:1] : tmp; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "89",
                    "name": "GLOBAL_ATOMIC_AND_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] &= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "90",
                    "name": "GLOBAL_ATOMIC_OR_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "91",
                    "name": "GLOBAL_ATOMIC_XOR_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA[0:1]; RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "92",
                    "name": "GLOBAL_ATOMIC_INC_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp >= DATA[0:1]) ? 0 : tmp + 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "93",
                    "name": "GLOBAL_ATOMIC_DEC_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0 || tmp > DATA[0:1]) ? DATA[0:1] : tmp - 1; // unsigned compare RETURN_DATA[0:1] = tmp."
                },
                {
                    "opcode": "94",
                    "name": "GLOBAL_ATOMIC_FCMPSWAP_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare swap (handles NaN/INF/denorm)."
                },
                {
                    "opcode": "95",
                    "name": "GLOBAL_ATOMIC_FMIN_X2",
                    "short": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp",
                    "description": "// 64bit tmp = MEM[ADDR]; src = DATA[0]; MEM[ADDR] = (src < tmp) ? src : tmp; RETURN_DATA[0] = tmp. Floating-point compare (handles NaN/INF/denorm)."
                }
            ]
        }
    ]
}